<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    
    <!-- SEO Meta Tags -->
    <title>í˜¸ì†Œì¸ ì—ë””í„° - ì‹¤ì œ ì¸í”Œë£¨ì–¸ì„œê°€ ë§Œë“  ì´ˆê°„ë‹¨ ì‚¬ì§„ í¸ì§‘ê¸°</title>
    <meta name="description" content="ì¸í”Œë£¨ì–¸ì„œ í˜¸ì†Œì¸ì´ ì§ì ‘ ë§Œë“  ì½˜í…ì¸  íŠ¹í™” ì‚¬ì§„ í¸ì§‘ê¸°! ê´‘ê³  ì—†ì´ ë¹ ë¥´ê³  ê°„í¸í•˜ê²Œ ë¹„ìœ¨ ë³€ê²½, ì´ë¯¸ì§€ í•©ì¹˜ê¸°, ì½œë¼ì£¼, ê¾¸ë¯¸ê¸°, ë¶„í• , í…Œë‘ë¦¬ ë‹¤ë“¬ê¸°ë¥¼ ì¦ê²¨ë³´ì„¸ìš”.">
    <meta name="keywords" content="í˜¸ì†Œì¸, í˜¸ì†Œì¸ ì—ë””í„°, ê¹€ìŒ”ë­, ì´ë¯¸ì§€ í¸ì§‘, ì‚¬ì§„ í¸ì§‘, ì˜¨ë¼ì¸ ì—ë””í„°, ë¬´ë£Œ í¸ì§‘ ë„êµ¬, ì¸ìŠ¤íƒ€ê·¸ë¨ í¸ì§‘, ì½œë¼ì£¼ ë§Œë“¤ê¸°, ì´ë¯¸ì§€ í•©ì¹˜ê¸°, ë¹„ìœ¨ ë³€ê²½">
    <meta name="author" content="í˜¸ì†Œì¸ ì—ë””í„° by ê¹€ìŒ”ë­">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="í˜¸ì†Œì¸ ì—ë””í„° - ë¬´ë£Œ ì˜¨ë¼ì¸ ì´ë¯¸ì§€ í¸ì§‘ ë„êµ¬">
    <meta property="og:description" content="ë¹„ìœ¨ ë³€ê²½, ì´ë¯¸ì§€ í•©ì¹˜ê¸°, ì½œë¼ì£¼, ê¾¸ë¯¸ê¸° ë“± ë‹¤ì–‘í•œ ì´ë¯¸ì§€ í¸ì§‘ ê¸°ëŠ¥ì„ ë¬´ë£Œë¡œ ì œê³µí•©ë‹ˆë‹¤.">
    <meta property="og:image" content="https://hosoin-editor.com/og-image.jpg">
    <meta property="og:url" content="https://hosoin-editor.com">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="í˜¸ì†Œì¸ ì—ë””í„° - ë¬´ë£Œ ì˜¨ë¼ì¸ ì´ë¯¸ì§€ í¸ì§‘ ë„êµ¬">
    <meta name="twitter:description" content="ë¹„ìœ¨ ë³€ê²½, ì´ë¯¸ì§€ í•©ì¹˜ê¸°, ì½œë¼ì£¼, ê¾¸ë¯¸ê¸° ë“± ë‹¤ì–‘í•œ ì´ë¯¸ì§€ í¸ì§‘ ê¸°ëŠ¥ì„ ë¬´ë£Œë¡œ ì œê³µí•©ë‹ˆë‹¤.">
    <meta name="twitter:image" content="https://hosoin-editor.com/twitter-image.jpg">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    
    <!-- PWA Support -->
    <meta name="theme-color" content="#11593F">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="í˜¸ì†Œì¸ ì—ë””í„°">
    <link rel="manifest" href="/manifest.json">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Lucide Icons -->
    <!-- ë²„ì „ ê³ ì • ê¶Œì¥: @latest ëŒ€ì‹  íŠ¹ì • ë²„ì „ ì‚¬ìš© ì‹œ í˜¸í™˜ì„± ìœ ì§€ -->
    <script src="https://unpkg.com/lucide@0.294.0"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Nanum+Pen+Script&family=Jua&family=Dokdo&family=Gaegu:wght@300;400;700&family=Hi+Melody&display=swap" rel="stylesheet">
    
    <!-- Google Analytics - ì—¬ê¸°ì— ë³¸ì¸ì˜ GA ì½”ë“œ ì‚½ì… -->
    <!-- 
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX');
    </script>
    -->
    
    <!-- Google AdSense - ì—¬ê¸°ì— ë³¸ì¸ì˜ AdSense ì½”ë“œ ì‚½ì… -->
    <!--
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX"
         crossorigin="anonymous"></script>
    -->
    
    <style>
        /* --- ê¸°ë³¸ í…Œë§ˆ ì„¤ì • --- */
        :root { 
            --primary: #11593F;
            --secondary: #9575CD;
            --accent: #F27405;
            --bg-gray: #f4f6f8;
            --surface: #ffffff;
            --text-main: #333333;
            --border: #e0e0e0;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: rgba(45, 90, 39, 0.1); touch-action: manipulation; }
        body { 
            font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, sans-serif; 
            background-color: var(--bg-gray); 
            margin: 0; 
            padding: 10px; 
            color: var(--text-main); 
        }
        
        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
        }
        
        /* ê°€ë¡œ ëª¨ë“œ ëŒ€ì‘ */
        @media (orientation: landscape) and (max-height: 500px) {
            body {
                padding: 5px;
            }
            .app-header {
                padding: 10px 15px !important;
            }
            .app-header h1 {
                font-size: 16px !important;
            }
            .menu-grid {
                grid-template-columns: repeat(3, 1fr) !important;
            }
            #mainMenu {
                padding: 15px 10px !important;
            }
            .section-container {
                padding: 15px 10px !important;
            }
            .canvas-wrapper {
                max-height: 250px !important;
            }
            .control-panel {
                max-height: 200px;
                overflow-y: auto;
            }
            .tool-section {
                margin-bottom: 10px !important;
            }
        }

        
        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        .app-container { 
            max-width: 600px; 
            margin: 0 auto; 
            background: var(--surface); 
            border-radius: 24px; 
            box-shadow: 0 8px 30px rgba(0,0,0,0.08); 
            overflow: hidden; 
            border: 1px solid rgba(0,0,0,0.05);
        }

        /* í—¤ë” ì˜ì—­ */
        .app-header { 
            background: var(--primary); 
            color: white; 
            padding: 15px 20px; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            position: relative;
        }
        .app-header h1 { 
            margin: 0; 
            font-size: 20px; 
            font-weight: 700; 
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .mascot-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }
        .back-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 20px;
            transition: all 0.2s;
            position: absolute;
            right: 15px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            min-height: 40px;
        }
        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        .back-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        /* ë©”ì¸ ë©”ë‰´ í™”ë©´ */
        #mainMenu {
            padding: 30px 20px;
        }
        .menu-title {
            text-align: center;
            font-size: clamp(18px, 4.5vw, 24px);
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 30px;
            white-space: nowrap;
        }
        .menu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 15px;
        }
        
        @media (min-width: 768px) {
            .menu-grid {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }
        .menu-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 24px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            position: relative;
            overflow: hidden;
        }
        .menu-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 0;
        }
        .menu-card:hover::before {
            opacity: 0.08;
        }
        .menu-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 12px 24px rgba(45, 90, 39, 0.15);
            border-color: var(--primary);
        }
        .menu-card:active {
            transform: translateY(-2px) scale(1.01);
        }
        .menu-icon {
            font-size: 42px;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            color: #11593F;
        }
        .menu-label {
            font-size: 16px;
            font-weight: 800;
            color: var(--text-main);
            margin-bottom: 6px;
            position: relative;
            z-index: 1;
            letter-spacing: -0.3px;
        }
        .menu-desc {
            font-size: 12px;
            color: #666;
            line-height: 1.5;
            position: relative;
            z-index: 1;
        }

        /* ê° ê¸°ëŠ¥ í™”ë©´ (ê¸°ë³¸ ìˆ¨ê¹€) */
        .feature-screen {
            display: none;
        }
        .feature-screen.active {
            display: block;
        }

        /* ìº”ë²„ìŠ¤ ì˜ì—­ */
        .canvas-wrapper { 
            background: #eee; 
            width: 100%; 
            aspect-ratio: 1/1; 
            position: relative; 
            overflow: hidden; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            border-bottom: 1px solid var(--border);
            touch-action: none;
        }
        canvas { 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
            max-width: 100%; 
            max-height: 100%;
            touch-action: none;
        }

        /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        .control-panel { 
            padding: 20px; 
        }

        /* ê³µí†µ UI ìš”ì†Œ */
        .section-title { 
            font-size: 14px; 
            font-weight: 700; 
            color: #888; 
            margin-bottom: 12px; 
            display: flex; 
            align-items: center; 
            gap: 6px;
        }
        .tool-section { 
            margin-bottom: 20px; 
            border-bottom: 1px solid #eee; 
            padding-bottom: 20px; 
        }
        .tool-section:last-child { 
            border-bottom: none; 
            margin-bottom: 0; 
        }
        
        .input-group { 
            display: flex; 
            gap: 8px; 
            margin-bottom: 8px; 
            align-items: center; 
        }
        
        input[type="text"], select { 
            flex: 1; 
            padding: 10px; 
            border: 1px solid var(--border); 
            border-radius: 8px; 
            font-size: 14px; 
            outline: none; 
            background: #fafafa;
        }
        input[type="text"]:focus { 
            border-color: var(--primary); 
            background: white; 
        }
        
        input[type="range"] { 
            flex: 1; 
            height: 6px; 
            background: linear-gradient(to right, #e8f5e9 0%, #c8e6c9 100%); 
            border-radius: 10px; 
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        input[type="range"]:hover {
            background: linear-gradient(to right, #d4edd7 0%, #b5ddb8 100%);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #11593F 0%, #0d4530 100%);
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(17, 89, 63, 0.4), 0 1px 3px rgba(0,0,0,0.2);
            border: 3px solid white;
            transition: all 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(17, 89, 63, 0.5), 0 2px 4px rgba(0,0,0,0.3);
        }
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.05);
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #11593F 0%, #0d4530 100%);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 3px 8px rgba(17, 89, 63, 0.4), 0 1px 3px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(17, 89, 63, 0.5), 0 2px 4px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb:active {
            transform: scale(1.05);
        }
        input[type="color"] { 
            width: 36px; 
            height: 36px; 
            padding: 0; 
            border: none; 
            border-radius: 50%; 
            overflow: hidden; 
            cursor: pointer; 
        }

        .btn { 
            padding: 12px 18px; 
            border-radius: 10px; 
            border: none; 
            cursor: pointer; 
            font-weight: 700; 
            font-size: 14px; 
            transition: all 0.2s; 
            color: white;
            display: inline-flex; 
            align-items: center; 
            justify-content: center; 
            gap: 6px;
            min-height: 44px;
            touch-action: manipulation;
        }
        .btn:hover { 
            opacity: 0.9; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .btn:active { 
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .btn.primary { background: var(--primary); width: 100%; font-size: 15px; padding: 14px; margin-top: 10px; }
        .btn.secondary { background: #666; }
        .btn.accent { background: var(--secondary); }
        .btn.info { background: #2196F3; }
        .btn.danger { background: #ff4757; }
        .btn.small { padding: 8px 12px; font-size: 12px; }

        .file-upload-wrapper { 
            position: relative; 
            width: 100%; 
            margin-bottom: 10px; 
        }
        .file-upload-label {
            display: block; 
            width: 100%; 
            padding: 12px; 
            text-align: center;
            background: #e8f5e9; 
            color: var(--primary); 
            border: 2px dashed var(--primary);
            border-radius: 10px; 
            cursor: pointer; 
            font-weight: bold; 
            transition: all 0.2s;
        }
        .file-upload-label:hover { 
            background: #dcedc8; 
        }
        input[type="file"] { 
            display: none; 
        }

        .hidden { 
            display: none; 
        }

        /* ë¹„ìœ¨ ì„ íƒ ê·¸ë¦¬ë“œ */
        .ratio-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .ratio-btn {
            background: white;
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ratio-btn:hover {
            border-color: var(--primary);
            background: #f0f8f0;
        }
        .ratio-btn.selected {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }
        .ratio-label {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 5px;
        }
        .ratio-value {
            font-size: 12px;
            color: #666;
        }
        .ratio-btn.selected .ratio-value {
            color: rgba(255,255,255,0.8);
        }
        
        
        /* ì½œë¼ì£¼ ëª¨ë“œ ë²„íŠ¼ */
        .collage-mode-btn {
            cursor: pointer; 
            padding: 16px; 
            border: 3px solid #ddd; 
            border-radius: 12px; 
            transition: all 0.3s; 
            background: white;
            min-height: 110px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .collage-mode-btn:hover {
            border-color: var(--primary);
            background: #f0f8f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(17, 89, 63, 0.15);
        }
        .collage-mode-btn:active {
            transform: translateY(0);
        }
        .collage-mode-btn.selected {
            border-color: var(--primary);
            background: var(--primary);
        }
        .collage-mode-btn.selected > div:last-child {
            color: white;
        }
        .collage-mode-btn.selected > div:first-child > div,
        .collage-mode-btn.selected > div:first-child > div > div {
            background: white !important;
        }
        
        /* ë°˜ì‘í˜•: ì‘ì€ í™”ë©´ì—ì„œ ê¸€ì í¬ê¸° ì¡°ì • */
        @media (max-width: 400px) {
            .collage-mode-btn {
                padding: 12px;
                min-height: 100px;
            }
            .collage-mode-btn > div:last-child {
                font-size: 10px;
            }
        }
        

        /* ì‘ì€ í™”ë©´ ë°˜ì‘í˜• ê°œì„  */
        @media (max-width: 480px) {
            .app-header h1 {
                font-size: 18px;
            }
            
            .menu-grid {
                gap: 10px;
            }
            
            .menu-card {
                padding: 20px 12px;
            }
            
            .menu-icon {
                font-size: 36px;
            }
            
            .menu-label {
                font-size: 14px;
            }
            
            .menu-desc {
                font-size: 11px;
            }
            
            .control-panel {
                padding: 16px;
            }
            
            .input-group {
                flex-wrap: wrap;
            }
            
            .btn.primary {
                font-size: 14px;
                padding: 12px;
            }
            
            .ratio-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .file-upload-label {
                font-size: 13px;
                padding: 10px;
            }
        }
        
        /* ë§¤ìš° ì‘ì€ í™”ë©´ */
        @media (max-width: 360px) {
            body {
                padding: 5px;
            }
            
            .app-container {
                border-radius: 16px;
            }
            
            .app-header {
                padding: 12px 15px;
            }
            
            .menu-card {
                padding: 16px 10px;
            }
        }


        /* ë°°ê²½ìƒ‰ ë²„íŠ¼ ì„ íƒ ìŠ¤íƒ€ì¼ */
        .color-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            touch-action: manipulation;
        }
        .color-circle:hover {
            transform: scale(1.1);
        }
        .color-circle:active {
            transform: scale(1.15);
        }
        .color-circle.selected {
            box-shadow: 0 0 0 3px var(--primary);
            transform: scale(1.15);
        }
        .color-circle.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--primary);
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 3px white;
        }
        #bgBlack.selected::after {
            color: white;
            text-shadow: 0 0 3px black;
        }
        #bgGreen.selected::after {
            color: #FFD700;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        .rainbow-circle {
            position: relative;
            overflow: hidden;
        }
        .rainbow-circle::before {
            content: '';
            display: none;
        }
        #bgCustom.selected::before {
            display: none;
        }
        #bgCustom.selected::after {
            color: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.8);
        }

        /* ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° ë¦¬ìŠ¤íŠ¸ */
        .image-preview-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .image-preview-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .preview-thumb {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            background: #eee;
        }
        .preview-info {
            flex: 1;
            font-size: 13px;
        }
        .preview-name {
            font-weight: 600;
            margin-bottom: 3px;
        }
        .preview-size {
            color: #888;
            font-size: 11px;
        }
        .delete-preview-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }
    </style>
</head>
<body>

<div class="app-container">
    <header class="app-header" id="mainHeader">
        <h1 style="width: 100%; text-align: center;">
            ì¸í”Œë£¨ì–¸ì„œ í˜¸ì†Œì¸ Editor
        </h1>
    </header>
    
    <header class="app-header hidden" id="featureHeader">
        <h1>ì¸í”Œë£¨ì–¸ì„œ í˜¸ì†Œì¸ Editor</h1>
        <button class="back-btn" id="backBtn" onclick="goToMainMenu()"><</button>
    </header>

    <!-- ë©”ì¸ ë©”ë‰´ -->
    <div id="mainMenu">
        <div class="menu-title">âœ¨ ì›í•˜ëŠ” ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš”</div>
        
        <div class="menu-grid">
            <div class="menu-card" onclick="openFeature('ratio')">
                <div class="menu-icon"><i data-lucide="maximize-2" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ë¹„ìœ¨ ë³€ê²½</div>
                <div class="menu-desc">ì–´ë–¤ í”Œë«í¼ì´ë“ <br>ë”± ë§ê²Œ ë³€ê²½í•˜ê¸°</div>
            </div>
            <div class="menu-card" onclick="openFeature('merge')">
                <div class="menu-icon"><i data-lucide="git-merge" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ê²¹ì¹˜ê¸°</div>
                <div class="menu-desc">ì¸ë„¤ì¼ í”„ë ˆì„<br>ì‰½ê²Œ ì˜¬ë¦¬ê¸°</div>
            </div>
            <div class="menu-card" onclick="openFeature('collage')">
                <div class="menu-icon"><i data-lucide="layers" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ì½œë¼ì£¼</div>
                <div class="menu-desc">ëª¨ì•„ë³´ê¸° ì½˜í…ì¸ <br>ìµœì í™” ë ˆì´ì•„ì›ƒ</div>
            </div>
            <div class="menu-card" onclick="openFeature('decorate')">
                <div class="menu-icon"><i data-lucide="sparkles" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ê¾¸ë¯¸ê¸°</div>
                <div class="menu-desc">ê°€ë…ì„± 200%<br>ì •ë³´ ì½˜í…ì¸  ì „ìš© ê¾¸ë¯¸ê¸°</div>
            </div>
            <div class="menu-card" onclick="openFeature('split')">
                <div class="menu-icon"><i data-lucide="scissors" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ë¶„í• </div>
                <div class="menu-desc">ì‚¬ì§„ í•œ ì¥ìœ¼ë¡œ<br>ê³ í€„ ë¶„í•  í”¼ë“œ</div>
            </div>
            <div class="menu-card" onclick="openFeature('crop')">
                <div class="menu-icon"><i data-lucide="crop" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">í…Œë‘ë¦¬ ì»·</div>
                <div class="menu-desc">ì§€ì €ë¶„í•œ í…Œë‘ë¦¬<br>1ì´ˆë§Œì— ê¹”ë” ì •ë¦¬</div>
            </div>
            <div class="menu-card" onclick="openFeature('preview')">
                <div class="menu-icon"><i data-lucide="eye" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ë¯¸ë¦¬ë³´ê¸°</div>
                <div class="menu-desc">í”„ì‚¬ ë°”ê¾¸ê¸° ì „<br>í”„ë¡œí•„ ë¯¸ë¦¬ë³´ê¸°</div>
            </div>
            <div class="menu-card" onclick="openFeature('trim')">
                <div class="menu-icon"><i data-lucide="square-scissors" style="width:42px;height:42px;stroke-width:2;"></i></div>
                <div class="menu-label">ì´ë¯¸ì§€ ìë¥´ê¸°</div>
                <div class="menu-desc">ì›í•˜ëŠ” ë¶€ë¶„ë§Œ<br>ì†ì‰½ê²Œ ìë¥´ê¸°</div>
            </div>
        </div>
    </div>

    <!-- 1. ë¹„ìœ¨ ë³€ê²½ í™”ë©´ -->
    <div id="ratioScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="ratioCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
                <div class="file-upload-wrapper">
                    <label for="ratioUpload" class="file-upload-label">
                        + ì´ë¯¸ì§€ ì„ íƒí•˜ê¸°
                    </label>
                    <input type="file" id="ratioUpload" accept="image/*">
                </div>
            </div>
            
            <div class="tool-section">
                <div class="section-title">ğŸ“ ë¹„ìœ¨ ì„ íƒ</div>
                <div class="ratio-grid">
                    <div class="ratio-btn" onclick="selectRatio(1, 1, event)">
                        <div class="ratio-label">ì •ì‚¬ê°í˜•</div>
                        <div class="ratio-value">1:1 (ì¸ìŠ¤íƒ€ê·¸ë¨)</div>
                    </div>
                    <div class="ratio-btn" onclick="selectRatio(4, 5, event)">
                        <div class="ratio-label">ì„¸ë¡œí˜•</div>
                        <div class="ratio-value">4:5 (ì¸ìŠ¤íƒ€ í”¼ë“œ)</div>
                    </div>
                    <div class="ratio-btn" onclick="selectRatio(9, 16, event)">
                        <div class="ratio-label">ìŠ¤í† ë¦¬</div>
                        <div class="ratio-value">9:16 (ë¦´ìŠ¤, ìŠ¤í† ë¦¬)</div>
                    </div>
                    <div class="ratio-btn" onclick="selectRatio(16, 9, event)">
                        <div class="ratio-label">ê°€ë¡œí˜•</div>
                        <div class="ratio-value">16:9 (ìœ íŠœë¸Œ)</div>
                    </div>
                    <div class="ratio-btn" onclick="selectRatio('youtube', 0, event)">
                        <div class="ratio-label">ìœ íŠœë¸Œ ì±„ë„ì•„íŠ¸</div>
                        <div class="ratio-value">2560Ã—1440</div>
                    </div>
                    <div class="ratio-btn" onclick="selectRatio('twitter', 0, event)">
                        <div class="ratio-label">íŠ¸ìœ„í„° í—¤ë”</div>
                        <div class="ratio-value">1500Ã—500</div>
                    </div>
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">ğŸ¨ ë°°ê²½ìƒ‰</div>
                <div class="input-group" style="justify-content: center; gap: 15px;">
                    <div class="color-circle" id="bgWhite" onclick="selectBgColor('#ffffff', 'bgWhite')" style="background: #ffffff; border: 2px solid #ddd;"></div>
                    <div class="color-circle" id="bgBlack" onclick="selectBgColor('#000000', 'bgBlack')" style="background: #000000; border: 2px solid #333;"></div>
                    <div class="color-circle" id="bgGreen" onclick="selectBgColor('#11593F', 'bgGreen')" style="background: #11593F; border: 2px solid #0a3a28;"></div>
                    <div class="color-circle rainbow-circle" id="bgCustom" style="background: linear-gradient(135deg, #ff0000 0%, #ff7f00 15%, #ffff00 30%, #00ff00 45%, #0000ff 60%, #4b0082 75%, #9400d3 100%); border: 2px solid #999; cursor: pointer;">
                        <input type="color" id="customColorPicker" style="opacity: 0; width: 100%; height: 100%; position: absolute; top: 0; left: 0; cursor: pointer; border: none;">
                    </div>
                </div>
            </div>

            <div class="tool-section">
                <div style="display: flex; gap: 8px;">
                    <button class="btn secondary" onclick="alignRatioPosition('left')" style="flex: 1;">
                        <i data-lucide="align-left" style="width:16px;height:16px;"></i> ì¢Œì¸¡
                    </button>
                    <button class="btn secondary" onclick="alignRatioPosition('center')" style="flex: 1;">
                        <i data-lucide="align-center" style="width:16px;height:16px;"></i> ê°€ìš´ë°
                    </button>
                    <button class="btn secondary" onclick="alignRatioPosition('right')" style="flex: 1;">
                        <i data-lucide="align-right" style="width:16px;height:16px;"></i> ìš°ì¸¡
                    </button>
                </div>
                <p style="font-size: 11px; color: #888; margin: 5px 0 0 0; text-align: center;">
                    ğŸ’¡ í•€ì¹˜(ë‘ ì†ê°€ë½)ë¡œ í™•ëŒ€/ì¶•ì†Œ, ë“œë˜ê·¸ë¡œ ì´ë™ ê°€ëŠ¥
                </p>
            </div>

            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <button class="btn secondary" onclick="resetRatioAll()" style="flex: 1;">
                    <i data-lucide="rotate-ccw" style="width:16px;height:16px;"></i> ì‘ì—… ì´ˆê¸°í™”
                </button>
            </div>

            <div style="display: flex; gap: 10px;">
                <button class="btn primary" onclick="downloadRatioImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="shareRatioImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- 2. ì´ë¯¸ì§€ í•©ì¹˜ê¸° í™”ë©´ (ìƒˆë¡œìš´ ì˜¤ë²„ë ˆì´ ê¸°ëŠ¥) -->
    <div id="mergeScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="mergeCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ë°°ê²½ ì´ë¯¸ì§€ (ì•„ë˜ì¸µ)</div>
                <div class="file-upload-wrapper">
                    <label for="mergeBaseUpload" class="file-upload-label">
                        + ë°°ê²½ ì´ë¯¸ì§€ ì„ íƒ
                    </label>
                    <input type="file" id="mergeBaseUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">ğŸ–¼ï¸ ê²¹ì¹  ì´ë¯¸ì§€ (ìœ„ì¸µ)</div>
                <div class="file-upload-wrapper">
                    <label for="mergeOverlayUpload" class="file-upload-label" style="background:#fff3e0; border-color:#ffb74d; color:#f57c00;">
                        + ê²¹ì¹  ì´ë¯¸ì§€ ì„ íƒ (í…Œë‘ë¦¬, í”„ë ˆì„ ë“±)
                    </label>
                    <input type="file" id="mergeOverlayUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">âš™ï¸ ìœ„ì¹˜ ë° í¬ê¸° ì¡°ì •</div>
                
                <!-- ë ˆì´ì–´ ì„ íƒ -->
                <div style="margin-bottom: 12px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px; color: var(--text-main);">
                        ì¡°ì •í•  ë ˆì´ì–´
                    </label>
                    <select id="layerSelect" style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 12px; font-size: 15px; font-weight: 600; background: white;">
                        <option value="overlay">ğŸ–¼ï¸ ìœ„ì¸µ (í”„ë ˆì„)</option>
                        <option value="base">ğŸ“· ì•„ë˜ì¸µ (ë°°ê²½)</option>
                    </select>
                </div>
                
                <!-- ë ˆì´ì–´ ìˆœì„œ ë³€ê²½ -->
                <div style="margin-bottom: 20px;">
                    <button class="btn secondary" onclick="swapMergeLayers()" style="width: 100%;">
                        <i data-lucide="flip-vertical" style="width:16px;height:16px;"></i> ë ˆì´ì–´ ìˆœì„œ ë°”ê¾¸ê¸°
                    </button>
                    <p style="font-size: 10px; color: #888; margin: 5px 0 0 0; text-align: center;">
                        ìœ„ì¸µê³¼ ì•„ë˜ì¸µì„ ì„œë¡œ ë°”ê¿‰ë‹ˆë‹¤
                    </p>
                </div>
                
                <!-- ìœ„ì¹˜ X -->
                <div style="margin-bottom: 18px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; font-weight: 600; color: var(--text-main);">ìœ„ì¹˜ X</span>
                        <input type="number" id="overlayXInput" min="-50" max="150" value="50" style="width: 70px; padding: 6px; border: 2px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 600; text-align: center;">
                    </label>
                    <input type="range" id="overlayX" min="-50" max="150" value="50" step="1" style="width: 100%;">
                </div>
                
                <!-- ìœ„ì¹˜ Y -->
                <div style="margin-bottom: 18px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; font-weight: 600; color: var(--text-main);">ìœ„ì¹˜ Y</span>
                        <input type="number" id="overlayYInput" min="-50" max="150" value="50" style="width: 70px; padding: 6px; border: 2px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 600; text-align: center;">
                    </label>
                    <input type="range" id="overlayY" min="-50" max="150" value="50" step="1" style="width: 100%;">
                </div>
                
                <!-- í¬ê¸° -->
                <div style="margin-bottom: 18px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; font-weight: 600; color: var(--text-main);">í¬ê¸°</span>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="number" id="overlayScaleInput" min="10" max="200" value="100" style="width: 70px; padding: 6px; border: 2px solid var(--border); border-radius: 8px; font-size: 14px; font-weight: 600; text-align: center;">
                            <span style="font-size: 14px; color: var(--text-secondary);">%</span>
                        </div>
                    </label>
                    <input type="range" id="overlayScale" min="10" max="200" value="100" step="1" style="width: 100%;">
                </div>
                
                <!-- íˆ¬ëª…ë„ -->
                <div style="margin-bottom: 18px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; font-weight: 600; color: var(--text-main);">íˆ¬ëª…ë„</span>
                        <span id="opacityValue" style="font-size: 14px; font-weight: 600; color: var(--primary);">100%</span>
                    </label>
                    <input type="range" id="overlayOpacity" min="0" max="100" value="100" style="width: 100%;">
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button class="btn primary" onclick="downloadMergedImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="shareMergedImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- 3. ì´ë¯¸ì§€ ì½œë¼ì£¼ í™”ë©´ (ê¸°ì¡´ í•©ì¹˜ê¸° ê¸°ëŠ¥) -->
    <div id="collageScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="collageCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ì´ë¯¸ì§€ ì¶”ê°€ (ìµœëŒ€ 10ê°œ)</div>
                <div class="file-upload-wrapper">
                    <label for="collageUpload" class="file-upload-label">
                        + ì´ë¯¸ì§€ ì¶”ê°€í•˜ê¸°
                    </label>
                    <input type="file" id="collageUpload" accept="image/*" multiple>
                </div>
                <p style="font-size: 11px; color: #888; margin: 5px 0 0 0; text-align: center; background: #f0f8f0; padding: 10px; border-radius: 8px;">
                    ğŸ’¡ ìº”ë²„ìŠ¤ë¥¼ í„°ì¹˜í•˜ì—¬ ì´ë¯¸ì§€ë¥¼ ì„ íƒí•˜ê³ , ë‘ ì†ê°€ë½ìœ¼ë¡œ í¬ê¸°ë¥¼ ì¡°ì ˆí•˜ì„¸ìš”!
                </p>
                <div id="collagePreviewList" class="image-preview-list"></div>
            </div>

            <div class="tool-section">
                <div class="section-title">ğŸ“ ë ˆì´ì•„ì›ƒ ì„ íƒ</div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
                    <!-- ììœ  ë°°ì¹˜ -->
                    <div onclick="selectCollageMode('freeform', event)" id="collageFreeform" class="collage-mode-btn">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 2px; padding: 10px;">
                            <div style="width: 25px; height: 20px; background: #11593F; border-radius: 2px;"></div>
                            <div style="width: 15px; height: 30px; background: #11593F; border-radius: 2px;"></div>
                            <div style="width: 20px; height: 25px; background: #11593F; border-radius: 2px; margin-top: -5px;"></div>
                            <div style="width: 18px; height: 15px; background: #11593F; border-radius: 2px;"></div>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">ììœ  ë°°ì¹˜</div>
                    </div>
                    
                    <!-- ê°€ë¡œ -->
                    <div onclick="selectCollageMode('horizontal', event)" id="collageHorizontal" class="collage-mode-btn">
                        <div style="display: flex; gap: 3px; justify-content: center;">
                            <div style="width: 20px; height: 50px; background: #11593F; border-radius: 4px;"></div>
                            <div style="width: 20px; height: 50px; background: #11593F; border-radius: 4px;"></div>
                            <div style="width: 20px; height: 50px; background: #11593F; border-radius: 4px;"></div>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 10px; font-weight: 700;">ê°€ë¡œ</div>
                    </div>
                    
                    <!-- ì„¸ë¡œ -->
                    <div onclick="selectCollageMode('vertical', event)" id="collageVertical" class="collage-mode-btn">
                        <div style="display: flex; flex-direction: column; gap: 3px; justify-content: center; align-items: center;">
                            <div style="width: 65px; height: 14px; background: #11593F; border-radius: 4px;"></div>
                            <div style="width: 65px; height: 14px; background: #11593F; border-radius: 4px;"></div>
                            <div style="width: 65px; height: 14px; background: #11593F; border-radius: 4px;"></div>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 10px; font-weight: 700;">ì„¸ë¡œ</div>
                    </div>
                    
                    <!-- ê²©ì -->
                    <div onclick="selectCollageMode('grid', event)" id="collageGrid" class="collage-mode-btn">
                        <div style="display: flex; justify-content: center; align-items: center; padding: 10px 0;">
                            <i data-lucide="grid-2x2" style="width: 40px; height: 40px; color: #11593F;"></i>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">ê²©ì</div>
                    </div>
                    
                    <!-- ë©”ì¸+ì„œë¸Œ (í°ê±° 1ê°œ + ì‘ì€ê±° 3ê°œ) -->
                    <div onclick="selectCollageMode('main_sub', event)" id="collageMain_sub" class="collage-mode-btn">
                        <div style="display: flex; justify-content: center; align-items: center; padding: 10px 0;">
                            <i data-lucide="layout" style="width: 40px; height: 40px; color: #11593F;"></i>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">ë©”ì¸+ì„œë¸Œ</div>
                    </div>
                    
                    <!-- ë°˜ë°˜ ì„¸ë¡œ -->
                    <div onclick="selectCollageMode('half_vertical', event)" id="collageHalf_vertical" class="collage-mode-btn">
                        <div style="display: flex; justify-content: center; align-items: center; padding: 10px 0;">
                            <i data-lucide="columns-2" style="width: 40px; height: 40px; color: #11593F;"></i>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">ë°˜ë°˜ ì„¸ë¡œ</div>
                    </div>
                    
                    <!-- Lì -->
                    <div onclick="selectCollageMode('l_shape', event)" id="collageL_shape" class="collage-mode-btn">
                        <div style="display: flex; justify-content: center; align-items: center; padding: 10px 0;">
                            <i data-lucide="gallery-horizontal" style="width: 40px; height: 40px; color: #11593F;"></i>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">Lìí˜•</div>
                    </div>
                    
                    <!-- Tì -->
                    <div onclick="selectCollageMode('t_shape', event)" id="collageT_shape" class="collage-mode-btn">
                        <div style="display: flex; justify-content: center; align-items: center; padding: 10px 0;">
                            <i data-lucide="gallery-vertical" style="width: 40px; height: 40px; color: #11593F;"></i>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">Tìí˜•</div>
                    </div>
                    
                    <!-- ê³„ë‹¨ -->
                    <div onclick="selectCollageMode('stairs', event)" id="collageStairs" class="collage-mode-btn">
                        <div style="display: flex; justify-content: center; align-items: center; padding: 10px 0;">
                            <i data-lucide="bar-chart-3" style="width: 40px; height: 40px; color: #11593F;"></i>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 5px; font-weight: 700;">ê³„ë‹¨í˜•</div>
                    </div>
                </div>
                
                <!-- ê°„ê²© ì¡°ì ˆ -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; font-weight: 600; color: var(--text-main);">ì¹¸ ì‚¬ì´ ê°„ê²©</span>
                        <span id="collageGapValue" style="font-size: 14px; font-weight: 600; color: var(--primary);">10px</span>
                    </label>
                    <input type="range" id="collageGap" min="0" max="50" value="10" style="width: 100%;">
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button class="btn primary" onclick="downloadCollageImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="shareCollageImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- 4. ì´ë¯¸ì§€ ê¾¸ë¯¸ê¸° í™”ë©´ (ê¸°ì¡´ ê¸°ëŠ¥) -->
    <div id="decorateScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="decorateCanvas"></canvas>
        </div>

        <div class="control-panel">
            <!-- ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ ë²„íŠ¼ -->
            <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                <button class="btn secondary" id="undoBtn" onclick="undo()" disabled style="flex: 1; font-size: 13px;">
                    <i data-lucide="undo-2" style="width:14px;height:14px;"></i> ì‹¤í–‰ì·¨ì†Œ
                </button>
                <button class="btn secondary" id="redoBtn" onclick="redo()" disabled style="flex: 1; font-size: 13px;">
                    <i data-lucide="redo-2" style="width:14px;height:14px;"></i> ë‹¤ì‹œì‹¤í–‰
                </button>
            </div>
            
            <div class="tool-section">
                <div class="section-title">ğŸ–¼ï¸ ë°°ê²½ ì„¤ì •</div>
                <div class="file-upload-wrapper">
                    <label for="decorateUpload" class="file-upload-label">
                        + ë°°ê²½ ì‚¬ì§„ ë¶ˆëŸ¬ì˜¤ê¸°
                    </label>
                    <input type="file" id="decorateUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">ğŸ¨ ê¾¸ë¯¸ê¸° & ìœ„ì ¯</div>
                
                <div class="input-group">
                    <select id="widgetType" onchange="updateWidgetPlaceholder()" style="flex:0.4; min-width:80px;">
                        <option value="noti">ğŸ”” ì•Œë¦¼</option>
                        <option value="music">ğŸµ ìŒì•…</option>
                        <option value="location">ğŸ“ ìœ„ì¹˜</option>
                    </select>
                    <input type="text" id="widgetInput1" placeholder="ë³´ë‚¸ì‚¬ëŒ">
                </div>
                <div class="input-group">
                    <input type="text" id="widgetInput2" placeholder="ë‚´ìš© ì…ë ¥">
                    <button class="btn info small" onclick="createWidget()">ìƒì„±</button>
                </div>

                <div style="display:flex; gap:10px; margin-top:10px;">
                    <div class="file-upload-wrapper" style="margin:0; flex:1;">
                        <label for="stickerUpload" class="file-upload-label" style="background:#fff3e0; border-color:#ffb74d; color:#f57c00; padding:10px; font-size:13px;">
                            + ìŠ¤í‹°ì»¤(PNG) ì¶”ê°€
                        </label>
                        <input type="file" id="stickerUpload" accept="image/png, image/jpeg">
                    </div>
                </div>

            </div>

            <div id="selectedItemPanel" style="display: none; background: #fff8e1; border: 2px solid #ffecb3; padding: 15px; border-radius: 12px; margin-bottom: 20px;">
                <div class="section-title" style="color:#f57c00;">âš¡ ì„ íƒëœ ìš”ì†Œ í¸ì§‘</div>
                <div class="input-group">
                    <span style="font-size:12px;">í…Œë‘ë¦¬:</span>
                    <input type="color" id="itemBorderColor" value="#000000">
                    <input type="range" id="itemBorderWidth" min="0" max="20" value="0">
                </div>
                <div class="input-group">
                    <span style="font-size:12px;">í¬ê¸°:</span>
                    <input type="range" id="itemScale" min="10" max="200" value="100">
                    <button class="btn danger small" onclick="deleteSelectedItem()">ì‚­ì œ</button>
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">âœ¨ íš¨ê³¼</div>
                <div class="input-group">
                    <span style="font-size:12px; width:50px;">í•„í„°ë§‰:</span>
                    <select id="overlaySelect">
                        <option value="none">ì—†ìŒ</option>
                        <option value="black">ê²€ì€ìƒ‰ ë§‰</option>
                        <option value="white">í°ìƒ‰ ë§‰</option>
                        <option value="gradient-black">ê²€ì€ ê·¸ë¼ë°ì´ì…˜</option>
                        <option value="gradient-white">í°ìƒ‰ ê·¸ë¼ë°ì´ì…˜</option>
                    </select>
                    <input type="range" id="opacitySlider" min="0" max="100" value="50">
                </div>
                <div class="input-group">
                    <span style="font-size:12px; width:50px;">ê·¸ë¦¼ì:</span>
                    <input type="range" id="shadowSlider" min="0" max="50" value="0">
                    <span style="font-size:12px; width:50px; margin-left:10px;">ëª¨ì„œë¦¬:</span>
                    <input type="range" id="radiusSlider" min="0" max="100" value="0">
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button class="btn primary" onclick="downloadDecorateImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="shareDecorateImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- 5. ì´ë¯¸ì§€ ë¶„í•  í™”ë©´ -->
    <div id="splitScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="splitCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
                <div class="file-upload-wrapper">
                    <label for="splitUpload" class="file-upload-label">
                        + ë¶„í• í•  ì´ë¯¸ì§€ ì„ íƒ
                    </label>
                    <input type="file" id="splitUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">âœ‚ï¸ ë¶„í•  ë°©ì‹ (ì¸ìŠ¤íƒ€ê·¸ë¨ í”¼ë“œ 4:5 ë¹„ìœ¨)</div>
                <div class="ratio-grid">
                    <div class="ratio-btn" onclick="selectSplitMode(3, 1, event)">
                        <div class="ratio-label">ê°€ë¡œ 3ë¶„í• </div>
                        <div class="ratio-value">1í–‰ Ã— 3ì—´</div>
                    </div>
                    <div class="ratio-btn" onclick="selectSplitMode(3, 2, event)">
                        <div class="ratio-label">2Ã—3 ê²©ì</div>
                        <div class="ratio-value">6ê°œ ì¡°ê°</div>
                    </div>
                    <div class="ratio-btn" onclick="selectSplitMode(3, 3, event)">
                        <div class="ratio-label">3Ã—3 ê²©ì</div>
                        <div class="ratio-value">9ê°œ ì¡°ê°</div>
                    </div>
                </div>
                <div style="font-size:11px; color:#666; margin-top:10px; line-height:1.4;">
                    ğŸ’¡ ê° ì¡°ê°ì€ ì¸ìŠ¤íƒ€ê·¸ë¨ í”¼ë“œ ë¹„ìœ¨(4:5)ë¡œ ìë™ ì¡°ì •ë©ë‹ˆë‹¤
                </div>
            </div>

            <button class="btn primary" onclick="splitAndDownload()">âœ‚ï¸ ë¶„í•  í›„ ZIP ë‹¤ìš´ë¡œë“œ</button>
        </div>
    </div>

    <!-- 6. í…Œë‘ë¦¬ ë‹¤ë“¬ê¸° í™”ë©´ -->
    <div id="cropScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="cropCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
                <div class="file-upload-wrapper">
                    <label for="cropUpload" class="file-upload-label">
                        + í…Œë‘ë¦¬ ê¹ì„ ì´ë¯¸ì§€ ì„ íƒ
                    </label>
                    <input type="file" id="cropUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">âš™ï¸ í…Œë‘ë¦¬ ê¹ê¸° ì„¤ì •</div>
                <div class="input-group">
                    <span style="font-size:12px; width:80px;">ê¹ì„ ë‘ê»˜:</span>
                    <input type="range" id="cropAmount" min="1" max="50" value="5">
                    <span id="cropAmountValue" style="font-size:12px; font-weight:bold; min-width:50px;">5px</span>
                </div>
                <div style="font-size:11px; color:#666; margin-top:8px; line-height:1.5; background: #f0f8f0; padding: 12px; border-radius: 8px;">
                    ğŸ’¡ ëˆ„ë¼ë¡œ ì¸í•œ ì§€ì €ë¶„í•œ í…Œë‘ë¦¬ ì •ë¦¬
                </div>
            </div>

            <button class="btn primary" onclick="cropBorder()">âœ‚ï¸ í…Œë‘ë¦¬ ê¹ê¸°</button>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn secondary" onclick="downloadCroppedImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="shareCroppedImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- 7. ë¯¸ë¦¬ë³´ê¸° í™”ë©´ -->
    <div id="previewScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="previewCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
                <div class="file-upload-wrapper">
                    <label for="previewUpload" class="file-upload-label">
                        + ë°°ê²½ ì´ë¯¸ì§€ ì„ íƒ (í—¤ë”/ì»¤ë²„)
                    </label>
                    <input type="file" id="previewUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">ğŸ‘¤ í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ (ì„ íƒ)</div>
                <div class="file-upload-wrapper">
                    <label for="previewProfileUpload" class="file-upload-label" style="background:#e3f2fd; border-color:#64b5f6; color:#1976d2;">
                        + í”„ë¡œí•„ ì‚¬ì§„ ì„ íƒ
                    </label>
                    <input type="file" id="previewProfileUpload" accept="image/*">
                </div>
                <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">
                    ğŸ’¡ íŠ¸ìœ„í„°/í˜ì´ìŠ¤ë¶ ë¯¸ë¦¬ë³´ê¸°ì— í”„ë¡œí•„ ì‚¬ì§„ì´ í‘œì‹œë©ë‹ˆë‹¤
                </p>
            </div>

            <div class="tool-section">
                <div class="section-title">ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸° ëª¨ë“œ</div>
                <div class="ratio-grid">
                    <div class="ratio-btn" onclick="selectPreviewMode('profile', event)">
                        <div class="ratio-label">í”„ë¡œí•„</div>
                        <div class="ratio-value">ì›í˜• ë¯¸ë¦¬ë³´ê¸°</div>
                    </div>
                    <div class="ratio-btn" onclick="selectPreviewMode('youtube', event)">
                        <div class="ratio-label">ìœ íŠœë¸Œ ì±„ë„ì•„íŠ¸</div>
                        <div class="ratio-value">2560Ã—1440</div>
                    </div>
                    <div class="ratio-btn" onclick="selectPreviewMode('twitter', event)">
                        <div class="ratio-label">íŠ¸ìœ„í„° í—¤ë”</div>
                        <div class="ratio-value">1500Ã—500</div>
                    </div>
                    <div class="ratio-btn" onclick="selectPreviewMode('facebook', event)">
                        <div class="ratio-label">í˜ì´ìŠ¤ë¶ ì»¤ë²„</div>
                        <div class="ratio-value">820Ã—312</div>
                    </div>
                </div>
            </div>

            <div class="tool-section">
                <div style="display: flex; gap: 8px;">
                    <button class="btn secondary" onclick="alignPreviewPosition('left')" style="flex: 1;">
                        <i data-lucide="align-left" style="width:16px;height:16px;"></i> ì¢Œì¸¡
                    </button>
                    <button class="btn secondary" onclick="alignPreviewPosition('center')" style="flex: 1;">
                        <i data-lucide="align-center" style="width:16px;height:16px;"></i> ê°€ìš´ë°
                    </button>
                    <button class="btn secondary" onclick="alignPreviewPosition('right')" style="flex: 1;">
                        <i data-lucide="align-right" style="width:16px;height:16px;"></i> ìš°ì¸¡
                    </button>
                </div>
                <p style="font-size: 11px; color: #888; margin: 5px 0 0 0; text-align: center;">
                    ğŸ’¡ í•€ì¹˜(ë‘ ì†ê°€ë½)ë¡œ í™•ëŒ€/ì¶•ì†Œ, ë“œë˜ê·¸ë¡œ ì´ë™ ê°€ëŠ¥
                </p>
            </div>

            <div style="display: flex; gap: 10px;">
                <button class="btn primary" onclick="downloadPreviewImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="sharePreviewImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>

    <!-- 8. ì´ë¯¸ì§€ ìë¥´ê¸° í™”ë©´ -->
    <div id="trimScreen" class="feature-screen">
        <div class="canvas-wrapper">
            <canvas id="trimCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div class="tool-section">
                <div class="section-title">ğŸ“· ì´ë¯¸ì§€ ì—…ë¡œë“œ</div>
                <div class="file-upload-wrapper">
                    <label for="trimUpload" class="file-upload-label">
                        + ìë¥¼ ì´ë¯¸ì§€ ì„ íƒ
                    </label>
                    <input type="file" id="trimUpload" accept="image/*">
                </div>
            </div>

            <div class="tool-section">
                <div class="section-title">âœ‚ï¸ ìë¥´ê¸° ì˜ì—­ ì¡°ì •</div>
                <p style="font-size: 11px; color: #666; margin: 0 0 12px 0; line-height: 1.5; background: #f0f8f0; padding: 12px; border-radius: 8px;">
                    ğŸ’¡ ì´ˆë¡ ë°•ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ìë¥¼ ì˜ì—­ì„ ì„ íƒí•˜ì„¸ìš”
                </p>
                
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button class="btn secondary" onclick="resetTrimArea()" style="flex: 1;">
                        <i data-lucide="maximize" style="width:16px;height:16px;"></i> ì „ì²´ ì„ íƒ
                    </button>
                    <button class="btn secondary" onclick="setSquareTrim()" style="flex: 1;">
                        <i data-lucide="square" style="width:16px;height:16px;"></i> ì •ì‚¬ê°í˜•
                    </button>
                </div>
            </div>

            <button class="btn primary" onclick="executeTrim()">âœ‚ï¸ ìë¥´ê¸° ì‹¤í–‰</button>
            <button class="btn secondary" onclick="resetTrimAll()" style="width: 100%; margin-top: 10px;">
                <i data-lucide="rotate-ccw" style="width:16px;height:16px;"></i> ì‘ì—… ì´ˆê¸°í™”
            </button>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="btn secondary" onclick="downloadTrimmedImage()" style="flex: 1;">ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                <button class="btn secondary" onclick="shareTrimmedImage()" style="flex: 1;"><i data-lucide="share-2" style="width:16px;height:16px;"></i> ê³µìœ </button>
            </div>
        </div>
    </div>
</div>

<script>
    // roundRect polyfill
    if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
            return this;
        };
    }

    // ===== ì „ì—­ ë³€ìˆ˜ ë° ìƒíƒœ ê´€ë¦¬ =====
    let currentFeature = null;
    
    // ì„±ëŠ¥ ìµœì í™”: requestAnimationFrame ê¸°ë°˜ ì“°ë¡œí‹€ë§
    let ratioRafId = null;
    let mergeRafId = null;
    let collageRafId = null;

    // ===== ë©”ì¸ ë©”ë‰´ ë„¤ë¹„ê²Œì´ì…˜ =====
    function openFeature(feature) {
        currentFeature = feature;
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('mainHeader').classList.add('hidden');
        document.getElementById('featureHeader').classList.remove('hidden');
        
        // ëª¨ë“  í™”ë©´ ìˆ¨ê¸°ê¸°
        document.querySelectorAll('.feature-screen').forEach(screen => {
            screen.classList.remove('active');
        });
        
        // ì„ íƒí•œ í™”ë©´ë§Œ í‘œì‹œ
        const screenMap = {
            'ratio': 'ratioScreen',
            'merge': 'mergeScreen',
            'collage': 'collageScreen',
            'decorate': 'decorateScreen',
            'split': 'splitScreen',
            'crop': 'cropScreen',
            'preview': 'previewScreen',
            'trim': 'trimScreen'
        };
        
        document.getElementById(screenMap[feature]).classList.add('active');
        
        // ê° ê¸°ëŠ¥ ì´ˆê¸°í™”
        if (feature === 'ratio') initRatio();
        if (feature === 'merge') initMerge();
        if (feature === 'collage') initCollage();
        if (feature === 'decorate') initDecorate();
        if (feature === 'split') initSplit();
        if (feature === 'crop') initCrop();
        if (feature === 'preview') initPreview();
        if (feature === 'trim') initTrim();
    }

    function goToMainMenu() {
        currentFeature = null;
        document.getElementById('mainMenu').style.display = 'block';
        document.getElementById('mainHeader').classList.remove('hidden');
        document.getElementById('featureHeader').classList.add('hidden');
        document.querySelectorAll('.feature-screen').forEach(screen => {
            screen.classList.remove('active');
        });
    }

    // ===== 1. ë¹„ìœ¨ ë³€ê²½ ê¸°ëŠ¥ =====
    let ratioImg = new Image();
    let ratioOriginalFileName = '';
    let ratioCanvas, ratioCtx;
    let ratioInitialized = false;
    let selectedRatioW = 1, selectedRatioH = 1;
    let ratioBgColor = '#ffffff';
    
    // ë“œë˜ê·¸ ê´€ë ¨ ë³€ìˆ˜
    let ratioOffsetX = 0, ratioOffsetY = 0;
    let ratioScale = 1;
    let ratioIsDragging = false;
    let ratioStartX = 0, ratioStartY = 0;
    
    // í•€ì¹˜ ì¤Œ ê´€ë ¨ ë³€ìˆ˜
    let ratioInitialDistance = 0;
    let ratioInitialScale = 1;

    function initRatio() {
        if (ratioInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        ratioInitialized = true;
        
        ratioCanvas = document.getElementById('ratioCanvas');
        ratioCtx = ratioCanvas.getContext('2d');
        ratioCanvas.width = 500;
        ratioCanvas.height = 500;
        
        // ê¸°ë³¸ ë°°ê²½ìƒ‰ í•˜ì–€ìƒ‰ìœ¼ë¡œ ì„ íƒ
        selectBgColor('#ffffff', 'bgWhite');
        
        // ì»¤ìŠ¤í…€ ì»¬ëŸ¬ í”¼ì»¤ ì´ë²¤íŠ¸
        document.getElementById('customColorPicker').onchange = function(e) {
            const customColor = e.target.value;
            selectBgColor(customColor, 'bgCustom');
            drawRatioImage();
        };
        
        document.getElementById('ratioUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // ì›ë³¸ íŒŒì¼ëª… ì €ì¥ (í™•ì¥ì ì œê±°)
            ratioOriginalFileName = file.name.replace(/\.[^/.]+$/, "");
            
            const reader = new FileReader();
            reader.onload = function(ev) {
                ratioImg.src = ev.target.result;
                ratioImg.onload = function() {
                    // ì´ë¯¸ì§€ ë¡œë“œ ì‹œ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                    ratioOffsetX = 0;
                    ratioOffsetY = 0;
                    ratioScale = 1;
                    drawRatioImage();
                };
            };
            reader.readAsDataURL(file);
        };
        
        // ë“œë˜ê·¸ ì´ë²¤íŠ¸
        ratioCanvas.addEventListener('mousedown', ratioStartDrag);
        ratioCanvas.addEventListener('touchstart', ratioStartDrag, {passive: false});
        ratioCanvas.addEventListener('mousemove', ratioDrag);
        ratioCanvas.addEventListener('touchmove', ratioDrag, {passive: false});
        ratioCanvas.addEventListener('mouseup', ratioEndDrag);
        ratioCanvas.addEventListener('touchend', ratioEndDrag);
        ratioCanvas.addEventListener('mouseleave', ratioEndDrag);
        
        // ë§ˆìš°ìŠ¤ íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ
        ratioCanvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            if (!ratioImg.src) return;
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            ratioScale = Math.max(0.1, Math.min(5, ratioScale * delta));
            drawRatioImage();
        }, {passive: false});
    }
    
    function ratioStartDrag(e) {
        if (!ratioImg.src) return;
        if (e.type === 'touchstart') e.preventDefault();
        
        // ë‘ ì†ê°€ë½ í„°ì¹˜ - í•€ì¹˜ ì¤Œ
        if (e.type === 'touchstart' && e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            ratioInitialDistance = Math.sqrt(dx * dx + dy * dy);
            ratioInitialScale = ratioScale;
            ratioIsDragging = false;
            return;
        }
        
        const rect = ratioCanvas.getBoundingClientRect();
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        
        ratioIsDragging = true;
        ratioStartX = clientX - rect.left - ratioOffsetX;
        ratioStartY = clientY - rect.top - ratioOffsetY;
    }
    
    function ratioDrag(e) {
        if (e.type === 'touchmove') e.preventDefault();
        
        // ë‘ ì†ê°€ë½ í„°ì¹˜ - í•€ì¹˜ ì¤Œ
        if (e.type === 'touchmove' && e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            ratioScale = Math.max(0.1, Math.min(5, ratioInitialScale * (distance / ratioInitialDistance)));
            if (ratioRafId) cancelAnimationFrame(ratioRafId);
            ratioRafId = requestAnimationFrame(function() {
                ratioRafId = null;
                drawRatioImage();
            });
            return;
        }
        
        if (!ratioIsDragging) return;
        
        const rect = ratioCanvas.getBoundingClientRect();
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        
        ratioOffsetX = clientX - rect.left - ratioStartX;
        ratioOffsetY = clientY - rect.top - ratioStartY;
        
        if (ratioRafId) cancelAnimationFrame(ratioRafId);
        ratioRafId = requestAnimationFrame(function() {
            ratioRafId = null;
            drawRatioImage();
        });
    }
    
    function ratioEndDrag() {
        ratioIsDragging = false;
    }
    
    // ì •ê°€ìš´ë° ì¬ë°°ì¹˜ í•¨ìˆ˜
    function alignRatioPosition(align) {
        if (!ratioImg.src) return;
        
        ratioScale = 1;
        ratioOffsetY = 0;
        
        // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ì— ë§ì¶°ì§€ëŠ” ì‹¤ì œ í¬ê¸° ê³„ì‚°
        const scale = Math.min(
            ratioCanvas.width / ratioImg.width,
            ratioCanvas.height / ratioImg.height
        );
        const scaledW = ratioImg.width * scale;
        
        if (align === 'left') {
            // ì™¼ìª½ ì •ë ¬: ì´ë¯¸ì§€ ì™¼ìª½ ëì´ ìº”ë²„ìŠ¤ ì™¼ìª½ì— ë¶™ë„ë¡
            ratioOffsetX = -scaledW / 2;
        } else if (align === 'center') {
            // ê°€ìš´ë° ì •ë ¬: ê¸°ë³¸ê°’
            ratioOffsetX = 0;
        } else if (align === 'right') {
            // ìš°ì¸¡ ì •ë ¬: ì´ë¯¸ì§€ ì˜¤ë¥¸ìª½ ëì´ ìº”ë²„ìŠ¤ ì˜¤ë¥¸ìª½ì— ë¶™ë„ë¡
            ratioOffsetX = (ratioCanvas.width - scaledW) / 2;
        }
        
        drawRatioImage();
    }
    
    // í˜¸í™˜ì„±ì„ ìœ„í•œ ê¸°ì¡´ í•¨ìˆ˜ ìœ ì§€
    function resetRatioPosition() {
        alignRatioPosition('center');
    }

    function selectBgColor(color, btnId) {
        ratioBgColor = color;
        
        // ëª¨ë“  ë°°ê²½ìƒ‰ ë²„íŠ¼ ì„ íƒ í•´ì œ
        ['bgWhite', 'bgBlack', 'bgGreen', 'bgCustom'].forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.classList.remove('selected');
            }
        });
        
        // ì„ íƒëœ ë²„íŠ¼ë§Œ í™œì„±í™”
        const selectedBtn = document.getElementById(btnId);
        if (selectedBtn) {
            selectedBtn.classList.add('selected');
        }
        
        drawRatioImage();
    }

    function openColorPicker() {
        // ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ - inputì— ì§ì ‘ ì—°ê²°
    }

    function selectRatio(w, h, evt) {
        selectedRatioW = w;
        selectedRatioH = h;
        
        document.querySelectorAll('.ratio-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        const e = evt || (typeof event !== 'undefined' ? event : null);
        if (e && e.currentTarget) e.currentTarget.classList.add('selected');
        
        drawRatioImage();
    }

    function drawRatioImage() {
        if (!ratioImg.src) return;
        
        const maxSize = 500;
        let canvasWidth, canvasHeight;
        let showYoutubeGuide = false;
        let showTwitterGuide = false;
        let showStoryGuide = false;
        
        // íŠ¹ìˆ˜ ë¹„ìœ¨ ì²˜ë¦¬
        if (selectedRatioW === 'youtube') {
            canvasWidth = maxSize;
            canvasHeight = maxSize * (1440 / 2560);
            showYoutubeGuide = true;
        } else if (selectedRatioW === 'twitter') {
            canvasWidth = maxSize;
            canvasHeight = maxSize * (500 / 1500);
            showTwitterGuide = true;
        } else {
            canvasWidth = maxSize;
            canvasHeight = maxSize * (selectedRatioH / selectedRatioW);
            
            // ì¸ìŠ¤íƒ€ ìŠ¤í† ë¦¬/ë¦´ìŠ¤ (9:16) ê°ì§€
            if (selectedRatioW === 9 && selectedRatioH === 16) {
                showStoryGuide = true;
            }
        }
        
        ratioCanvas.width = canvasWidth;
        ratioCanvas.height = canvasHeight;
        
        ratioCtx.fillStyle = ratioBgColor;
        ratioCtx.fillRect(0, 0, ratioCanvas.width, ratioCanvas.height);
        
        // ì´ë¯¸ì§€ í¬ê¸° ê³„ì‚° (ì—¬ë°± ìƒì„± - ì´ë¯¸ì§€ë¥¼ ìë¥´ì§€ ì•ŠìŒ)
        const scale = Math.min(
            ratioCanvas.width / ratioImg.width,
            ratioCanvas.height / ratioImg.height
        ) * ratioScale;
        
        const scaledW = ratioImg.width * scale;
        const scaledH = ratioImg.height * scale;
        const x = (ratioCanvas.width - scaledW) / 2 + ratioOffsetX;
        const y = (ratioCanvas.height - scaledH) / 2 + ratioOffsetY;
        
        ratioCtx.drawImage(ratioImg, x, y, scaledW, scaledH);
        
        // ì¸ìŠ¤íƒ€ ìŠ¤í† ë¦¬ ì•ˆì „ ì˜ì—­ ê°€ì´ë“œ
        if (showStoryGuide) {
            // ìƒë‹¨ í”„ë¡œí•„ ì˜ì—­ (ì•½ 250px, ë¹„ìœ¨: 14%)
            const topHeight = ratioCanvas.height * 0.14;
            // í•˜ë‹¨ ëŒ“ê¸€/ì•¡ì…˜ ì˜ì—­ (ì•½ 300px, ë¹„ìœ¨: 17%)
            const bottomHeight = ratioCanvas.height * 0.17;
            
            ratioCtx.strokeStyle = '#E1306C'; // ì¸ìŠ¤íƒ€ í•‘í¬
            ratioCtx.fillStyle = 'rgba(225, 48, 108, 0.1)';
            ratioCtx.lineWidth = 2;
            ratioCtx.setLineDash([8, 4]);
            
            // ìƒë‹¨ ìœ„í—˜ ì˜ì—­
            ratioCtx.fillRect(0, 0, ratioCanvas.width, topHeight);
            ratioCtx.strokeRect(0, 0, ratioCanvas.width, topHeight);
            
            // í•˜ë‹¨ ìœ„í—˜ ì˜ì—­
            ratioCtx.fillRect(0, ratioCanvas.height - bottomHeight, ratioCanvas.width, bottomHeight);
            ratioCtx.strokeRect(0, ratioCanvas.height - bottomHeight, ratioCanvas.width, bottomHeight);
            
            ratioCtx.setLineDash([]);
            
            // ì•ˆì „ ì˜ì—­ í‘œì‹œ
            const safeY = topHeight;
            const safeHeight = ratioCanvas.height - topHeight - bottomHeight;
            ratioCtx.strokeStyle = '#00D95F'; // ì¸ìŠ¤íƒ€ ê·¸ë¦°
            ratioCtx.lineWidth = 2;
            ratioCtx.setLineDash([10, 5]);
            ratioCtx.strokeRect(0, safeY, ratioCanvas.width, safeHeight);
            ratioCtx.setLineDash([]);
            
            // ì•ˆë‚´ í…ìŠ¤íŠ¸
            ratioCtx.fillStyle = '#E1306C';
            ratioCtx.font = 'bold 11px "Pretendard", sans-serif';
            ratioCtx.textAlign = 'center';
            ratioCtx.fillText('í”„ë¡œí•„/ì‹œê°„ ê°€ë¦¼', ratioCanvas.width / 2, topHeight / 2);
            ratioCtx.fillText('ëŒ“ê¸€/í•˜íŠ¸ ê°€ë¦¼', ratioCanvas.width / 2, ratioCanvas.height - bottomHeight / 2);
            
            ratioCtx.fillStyle = '#00D95F';
            ratioCtx.fillText('âœ“ ì•ˆì „ ì˜ì—­ (ê¸€ì”¨ ì—¬ê¸°ì—)', ratioCanvas.width / 2, safeY + safeHeight / 2);
        }
        
        // ìœ íŠœë¸Œ ì±„ë„ì•„íŠ¸ ì•ˆì „ ì˜ì—­ ê°€ì´ë“œ
        if (showYoutubeGuide) {
            const safeWidth = (1546 / 2560) * ratioCanvas.width;
            const safeHeight = (423 / 1440) * ratioCanvas.height;
            const safeX = (ratioCanvas.width - safeWidth) / 2;
            const safeY = (ratioCanvas.height - safeHeight) / 2;
            
            ratioCtx.strokeStyle = '#FF5722';
            ratioCtx.lineWidth = 2;
            ratioCtx.setLineDash([10, 5]);
            ratioCtx.strokeRect(safeX, safeY, safeWidth, safeHeight);
            ratioCtx.setLineDash([]);
            
            ratioCtx.fillStyle = 'rgba(255, 87, 34, 0.9)';
            ratioCtx.font = 'bold 12px "Pretendard", sans-serif';
            ratioCtx.textAlign = 'center';
            ratioCtx.fillText('ëª¨ë°”ì¼ ì•ˆì „ ì˜ì—­ (1546Ã—423)', ratioCanvas.width / 2, safeY - 10);
        }
        
        // íŠ¸ìœ„í„° í—¤ë” í”„ë¡œí•„ ì‚¬ì§„ ë¯¸ë¦¬ë³´ê¸°
        if (showTwitterGuide) {
            const profileSize = (200 / 1500) * ratioCanvas.width;
            const profileX = (16 / 1500) * ratioCanvas.width;
            const profileY = ratioCanvas.height - profileSize / 2;
            
            // í”„ë¡œí•„ ì‚¬ì§„ ì›í˜• ê°€ì´ë“œ
            ratioCtx.strokeStyle = '#1DA1F2'; // íŠ¸ìœ„í„° ë¸”ë£¨
            ratioCtx.fillStyle = 'rgba(29, 161, 242, 0.15)';
            ratioCtx.lineWidth = 3;
            ratioCtx.setLineDash([]);
            
            // ì› ê·¸ë¦¬ê¸°
            ratioCtx.beginPath();
            ratioCtx.arc(
                profileX + profileSize / 2, 
                profileY, 
                profileSize / 2, 
                0, 
                Math.PI * 2
            );
            ratioCtx.fill();
            ratioCtx.stroke();
            
            // ì•ˆë‚´ í…ìŠ¤íŠ¸
            ratioCtx.fillStyle = '#1DA1F2';
            ratioCtx.font = 'bold 10px "Pretendard", sans-serif';
            ratioCtx.textAlign = 'left';
            ratioCtx.fillText('í”„ë¡œí•„ ì‚¬ì§„ ìœ„ì¹˜', profileX + profileSize + 10, profileY);
        }
    }

    function resetRatioAll() {
        if (!ratioImg.src) {
            alert('ì—…ë¡œë“œëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        if (confirm('ëª¨ë“  ì‘ì—…ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            ratioOffsetX = 0;
            ratioOffsetY = 0;
            ratioScale = 1;
            selectBgColor('#ffffff', 'bgWhite');
            drawRatioImage();
        }
    }

    function downloadRatioImage() {
        if (!ratioImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        try {
            // ì‹¤ì œ ë‹¤ìš´ë¡œë“œ í¬ê¸° ê²°ì •
            let downloadWidth, downloadHeight;
            
            if (selectedRatioW === 'youtube') {
                downloadWidth = 2560;
                downloadHeight = 1440;
            } else if (selectedRatioW === 'twitter') {
                downloadWidth = 1500;
                downloadHeight = 500;
            } else {
                // ì¼ë°˜ ë¹„ìœ¨ - ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìµœëŒ€ í¬ê¸° ê³„ì‚°
                const maxDimension = 2048;
                if (selectedRatioW >= selectedRatioH) {
                    downloadWidth = maxDimension;
                    downloadHeight = maxDimension * (selectedRatioH / selectedRatioW);
                } else {
                    downloadHeight = maxDimension;
                    downloadWidth = maxDimension * (selectedRatioW / selectedRatioH);
                }
            }
            
            // ë‹¤ìš´ë¡œë“œìš© ìº”ë²„ìŠ¤ ìƒì„±
            const downloadCanvas = document.createElement('canvas');
            downloadCanvas.width = downloadWidth;
            downloadCanvas.height = downloadHeight;
            const downloadCtx = downloadCanvas.getContext('2d');
            
            // ë°°ê²½ìƒ‰ ì±„ìš°ê¸°
            downloadCtx.fillStyle = ratioBgColor;
            downloadCtx.fillRect(0, 0, downloadWidth, downloadHeight);
            
            // ë¯¸ë¦¬ë³´ê¸° ìŠ¤ì¼€ì¼ ê³„ì‚°
            const previewScale = Math.min(
                ratioCanvas.width / ratioImg.width,
                ratioCanvas.height / ratioImg.height
            ) * ratioScale;
            
            // ë‹¤ìš´ë¡œë“œ ìŠ¤ì¼€ì¼ ê³„ì‚°
            const downloadScale = Math.min(
                downloadWidth / ratioImg.width,
                downloadHeight / ratioImg.height
            ) * ratioScale;
            
            // ì˜¤í”„ì…‹ ë¹„ìœ¨ ê³„ì‚° (ë¯¸ë¦¬ë³´ê¸° -> ë‹¤ìš´ë¡œë“œ)
            const offsetScaleRatio = downloadScale / previewScale;
            
            const scaledW = ratioImg.width * downloadScale;
            const scaledH = ratioImg.height * downloadScale;
            const x = (downloadWidth - scaledW) / 2 + (ratioOffsetX * offsetScaleRatio);
            const y = (downloadHeight - scaledH) / 2 + (ratioOffsetY * offsetScaleRatio);
            
            downloadCtx.drawImage(ratioImg, x, y, scaledW, scaledH);
            
            // ìœ íŠœë¸Œ ì±„ë„ ì•„íŠ¸ ê°€ì´ë“œ ì¶”ê°€
            if (selectedRatioW === 'youtube') {
                const safeX = (downloadWidth - 1546) / 2;
                const safeY = (downloadHeight - 423) / 2;
                downloadCtx.strokeStyle = '#F27405';
                downloadCtx.lineWidth = 4;
                downloadCtx.setLineDash([20, 10]);
                downloadCtx.strokeRect(safeX, safeY, 1546, 423);
                downloadCtx.setLineDash([]);
            }
            
            // íŠ¸ìœ„í„° í—¤ë” í”„ë¡œí•„ ì‚¬ì§„ ê°€ì´ë“œ ì¶”ê°€
            if (selectedRatioW === 'twitter') {
                const profileSize = 200;
                const profileX = 16;
                const profileY = downloadHeight - profileSize / 2;
                
                downloadCtx.strokeStyle = '#1DA1F2';
                downloadCtx.fillStyle = 'rgba(29, 161, 242, 0.15)';
                downloadCtx.lineWidth = 6;
                downloadCtx.setLineDash([]);
                
                downloadCtx.beginPath();
                downloadCtx.arc(
                    profileX + profileSize / 2, 
                    profileY, 
                    profileSize / 2, 
                    0, 
                    Math.PI * 2
                );
                downloadCtx.fill();
                downloadCtx.stroke();
            }
            
            // Blob ì‚¬ìš©ìœ¼ë¡œ ê°•í™”ëœ ë‹¤ìš´ë¡œë“œ
            downloadCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // ì›ë³¸ íŒŒì¼ëª…ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ ì´ë¦„
                const fileName = ratioOriginalFileName ? 
                    `${ratioOriginalFileName}_í˜¸ì†Œì¸í¸ì§‘.png` : 
                    `í˜¸ì†Œì¸_${getFormattedDate()}.png`;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
            
        } catch (error) {
            console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
            alert('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }

    // ===== 2. ì´ë¯¸ì§€ í•©ì¹˜ê¸° ê¸°ëŠ¥ (ì˜¤ë²„ë ˆì´) =====
    let mergeBaseImg = new Image();
    let mergeOverlayImg = new Image();
    let mergeCanvas, mergeCtx;
    let mergeInitialized = false;
    
    // ë ˆì´ì–´ë³„ ìœ„ì¹˜/í¬ê¸° ì €ì¥
    let baseLayerSettings = { x: 50, y: 50, scale: 100, opacity: 100 };
    let overlayLayerSettings = { x: 50, y: 50, scale: 100, opacity: 100 };

    function initMerge() {
        if (mergeInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        mergeInitialized = true;
        
        mergeCanvas = document.getElementById('mergeCanvas');
        mergeCtx = mergeCanvas.getContext('2d');
        mergeCanvas.width = 500;
        mergeCanvas.height = 500;
        
        document.getElementById('mergeBaseUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                mergeBaseImg.src = ev.target.result;
                mergeBaseImg.onload = function() {
                    mergeCanvas.width = mergeBaseImg.width;
                    mergeCanvas.height = mergeBaseImg.height;
                    
                    // ê²¹ì¹  ì´ë¯¸ì§€ê°€ ì´ë¯¸ ìˆìœ¼ë©´ ë¹„ìœ¨ ì²´í¬
                    if (mergeOverlayImg.src) {
                        checkAndAutoFit();
                    }
                    drawMergedImage();
                };
            };
            reader.readAsDataURL(file);
        };
        
        document.getElementById('mergeOverlayUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                mergeOverlayImg.src = ev.target.result;
                mergeOverlayImg.onload = function() {
                    checkAndAutoFit();
                    drawMergedImage();
                };
            };
            reader.readAsDataURL(file);
        };
        
        // ìì„ íš¨ê³¼ê°€ ìˆëŠ” ìŠ¬ë¼ì´ë”
        function applyMagneticSnap(slider, input, magnetPoints) {
            slider.oninput = function() {
                let val = parseInt(this.value);
                for (let point of magnetPoints) {
                    if (Math.abs(val - point) <= 3) {
                        val = point;
                        break;
                    }
                }
                this.value = val;
                input.value = val;
                saveCurrentLayerSettings();
                if (mergeRafId) cancelAnimationFrame(mergeRafId);
                mergeRafId = requestAnimationFrame(function() {
                    mergeRafId = null;
                    drawMergedImage();
                });
            };
            
            input.oninput = function() {
                let val = parseInt(this.value);
                if (val < parseInt(slider.min)) val = parseInt(slider.min);
                if (val > parseInt(slider.max)) val = parseInt(slider.max);
                slider.value = val;
                this.value = val;
                saveCurrentLayerSettings();
                if (mergeRafId) cancelAnimationFrame(mergeRafId);
                mergeRafId = requestAnimationFrame(function() {
                    mergeRafId = null;
                    drawMergedImage();
                });
            };
        }
        
        const magnetPoints = [1, 30, 50, 70, 100];
        applyMagneticSnap(
            document.getElementById('overlayX'),
            document.getElementById('overlayXInput'),
            magnetPoints
        );
        applyMagneticSnap(
            document.getElementById('overlayY'),
            document.getElementById('overlayYInput'),
            magnetPoints
        );
        
        // í¬ê¸° ìŠ¬ë¼ì´ë”
        const scaleSlider = document.getElementById('overlayScale');
        const scaleInput = document.getElementById('overlayScaleInput');
        function scheduleMergeDraw() {
            if (mergeRafId) cancelAnimationFrame(mergeRafId);
            mergeRafId = requestAnimationFrame(function() {
                mergeRafId = null;
                drawMergedImage();
            });
        }
        scaleSlider.oninput = function() {
            scaleInput.value = this.value;
            saveCurrentLayerSettings();
            scheduleMergeDraw();
        };
        scaleInput.oninput = function() {
            let val = parseInt(this.value);
            if (val < 10) val = 10;
            if (val > 200) val = 200;
            scaleSlider.value = val;
            this.value = val;
            saveCurrentLayerSettings();
            scheduleMergeDraw();
        };
        
        document.getElementById('overlayOpacity').oninput = function() {
            document.getElementById('opacityValue').textContent = this.value + '%';
            saveCurrentLayerSettings();
            scheduleMergeDraw();
        };
        
        // ë ˆì´ì–´ ì„ íƒ ì´ë²¤íŠ¸
        document.getElementById('layerSelect').onchange = function() {
            saveCurrentLayerSettings();
            loadLayerSettings();
        };
    }
    
    // í˜„ì¬ ì„ íƒëœ ë ˆì´ì–´ì˜ ì„¤ì • ì €ì¥
    function saveCurrentLayerSettings() {
        const layer = document.getElementById('layerSelect').value;
        const settings = {
            x: parseInt(document.getElementById('overlayX').value),
            y: parseInt(document.getElementById('overlayY').value),
            scale: parseInt(document.getElementById('overlayScale').value),
            opacity: parseInt(document.getElementById('overlayOpacity').value)
        };
        
        if (layer === 'overlay') {
            overlayLayerSettings = settings;
        } else {
            baseLayerSettings = settings;
        }
    }
    
    // ì„ íƒëœ ë ˆì´ì–´ì˜ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
    function loadLayerSettings() {
        const layer = document.getElementById('layerSelect').value;
        const settings = (layer === 'overlay') ? overlayLayerSettings : baseLayerSettings;
        
        document.getElementById('overlayX').value = settings.x;
        document.getElementById('overlayXInput').value = settings.x;
        document.getElementById('overlayY').value = settings.y;
        document.getElementById('overlayYInput').value = settings.y;
        document.getElementById('overlayScale').value = settings.scale;
        document.getElementById('overlayScaleInput').value = settings.scale;
        document.getElementById('overlayOpacity').value = settings.opacity;
        document.getElementById('opacityValue').textContent = settings.opacity + '%';
        
        drawMergedImage();
    }
    
    function checkAndAutoFit() {
        // ë°°ê²½ê³¼ ê²¹ì¹  ì´ë¯¸ì§€ì˜ ë¹„ìœ¨ì´ ê°™ìœ¼ë©´ ì •í™•íˆ ë”± ë§ê²Œ ê²¹ì¹¨
        if (mergeBaseImg.src && mergeOverlayImg.src) {
            const baseRatio = mergeBaseImg.width / mergeBaseImg.height;
            const overlayRatio = mergeOverlayImg.width / mergeOverlayImg.height;
            
            // ë¹„ìœ¨ì´ ê±°ì˜ ê°™ìœ¼ë©´ (Â±5% ì˜¤ì°¨ í—ˆìš©)
            if (Math.abs(baseRatio - overlayRatio) / baseRatio < 0.05) {
                // ë°°ê²½ ì´ë¯¸ì§€ì— ì •í™•íˆ ë§ì¶¤
                const scaleX = mergeBaseImg.width / mergeOverlayImg.width;
                const scaleY = mergeBaseImg.height / mergeOverlayImg.height;
                const perfectScale = Math.round(Math.max(scaleX, scaleY) * 100); // ë°±ë¶„ìœ¨ë¡œ ë³€í™˜
                
                // ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ ì„¤ì • ì—…ë°ì´íŠ¸
                overlayLayerSettings.scale = perfectScale;
                overlayLayerSettings.x = 50;
                overlayLayerSettings.y = 50;
                
                // UI ì—…ë°ì´íŠ¸ (í˜„ì¬ ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ê°€ ì„ íƒëœ ê²½ìš°ì—ë§Œ)
                if (document.getElementById('layerSelect').value === 'overlay') {
                    document.getElementById('overlayScale').value = perfectScale;
                    document.getElementById('overlayScaleInput').value = perfectScale;
                    document.getElementById('overlayX').value = 50;
                    document.getElementById('overlayXInput').value = 50;
                    document.getElementById('overlayY').value = 50;
                    document.getElementById('overlayYInput').value = 50;
                }
                
                // ì•Œë¦¼
                console.log(`âœ… ê°™ì€ ë¹„ìœ¨ ê°ì§€! ì´ë¯¸ì§€ë¥¼ ì •í™•íˆ ë§ì·„ìŠµë‹ˆë‹¤. (ìŠ¤ì¼€ì¼: ${perfectScale}%)`);
            }
        }
    }

    function swapMergeLayers() {
        if (!mergeBaseImg.src || !mergeOverlayImg.src) {
            alert('ë‘ ì´ë¯¸ì§€ë¥¼ ëª¨ë‘ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // ì´ë¯¸ì§€ êµí™˜
        const tempSrc = mergeBaseImg.src;
        mergeBaseImg.src = mergeOverlayImg.src;
        mergeOverlayImg.src = tempSrc;
        
        // ì´ë¯¸ì§€ ë‹¤ì‹œ ë¡œë“œ (onload ë¹„ë™ê¸° race condition ë°©ì§€)
        const newBase = new Image();
        const newOverlay = new Image();
        
        newBase.src = mergeBaseImg.src;
        newOverlay.src = mergeOverlayImg.src;
        
        function applySwap() {
            mergeBaseImg = newBase;
            mergeOverlayImg = newOverlay;
            mergeCanvas.width = mergeBaseImg.width;
            mergeCanvas.height = mergeBaseImg.height;
            drawMergedImage();
        }
        
        if (newBase.complete && newOverlay.complete) {
            applySwap();
        } else {
            let baseLoaded = newBase.complete;
            let overlayLoaded = newOverlay.complete;
            newBase.onload = function() {
                baseLoaded = true;
                if (overlayLoaded) applySwap();
            };
            newOverlay.onload = function() {
                overlayLoaded = true;
                if (baseLoaded) applySwap();
            };
        }
    }

    function drawMergedImage() {
        if (!mergeBaseImg.src) return;
        
        try {
            mergeCtx.clearRect(0, 0, mergeCanvas.width, mergeCanvas.height);
            
            // ë°°ê²½ ë ˆì´ì–´ (ì•„ë˜ì¸µ) ê·¸ë¦¬ê¸°
            const baseScale = baseLayerSettings.scale / 100;
            const baseOpacity = baseLayerSettings.opacity / 100;
            const basePosX = baseLayerSettings.x; // 0~100
            const basePosY = baseLayerSettings.y; // 0~100
            
            const baseW = mergeBaseImg.width * baseScale;
            const baseH = mergeBaseImg.height * baseScale;
            
            // ë°°ê²½ ìœ„ì¹˜ ê³„ì‚° (50ì´ ì¤‘ì•™)
            const baseX = (mergeCanvas.width - baseW) * (basePosX / 100);
            const baseY = (mergeCanvas.height - baseH) * (basePosY / 100);
            
            mergeCtx.save();
            mergeCtx.globalAlpha = baseOpacity;
            mergeCtx.drawImage(mergeBaseImg, baseX, baseY, baseW, baseH);
            mergeCtx.restore();
            
            // ì˜¤ë²„ë ˆì´ ë ˆì´ì–´ (ìœ„ì¸µ) ê·¸ë¦¬ê¸°
            if (mergeOverlayImg.src && mergeOverlayImg.complete) {
                const overlayScale = overlayLayerSettings.scale / 100;
                const overlayOpacity = overlayLayerSettings.opacity / 100;
                const overlayPosX = overlayLayerSettings.x; // 0~100
                const overlayPosY = overlayLayerSettings.y; // 0~100
                
                const overlayW = mergeOverlayImg.width * overlayScale;
                const overlayH = mergeOverlayImg.height * overlayScale;
                
                // ì˜¤ë²„ë ˆì´ ìœ„ì¹˜ ê³„ì‚° (50ì´ ì¤‘ì•™)
                const overlayX = (mergeCanvas.width - overlayW) * (overlayPosX / 100);
                const overlayY = (mergeCanvas.height - overlayH) * (overlayPosY / 100);
                
                mergeCtx.save();
                mergeCtx.globalAlpha = overlayOpacity;
                mergeCtx.drawImage(mergeOverlayImg, overlayX, overlayY, overlayW, overlayH);
                mergeCtx.restore();
            }
        } catch (error) {
            console.error('ì´ë¯¸ì§€ ê²¹ì¹˜ê¸° ë Œë”ë§ ì˜¤ë¥˜:', error);
        }
    }

    function downloadMergedImage() {
        if (!mergeBaseImg.src) {
            alert('ë¨¼ì € ë°°ê²½ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        try {
            mergeCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `í˜¸ì†Œì¸_${getFormattedDate()}_ì¸ìŠ¤íƒ€ì‚¬ì´ì¦ˆ_1.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
        } catch (error) {
            console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
            alert('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }

    // ===== 3. ì´ë¯¸ì§€ ì½œë¼ì£¼ ê¸°ëŠ¥ (ê¸°ì¡´ í•©ì¹˜ê¸°) =====
    let collageImages_arr = [];
    let collageCanvas, collageCtx;
    let collageInitialized = false;
    let collageMode = 'horizontal'; // ê¸°ë³¸ê°’

    function initCollage() {
        if (collageInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        collageInitialized = true;
        
        collageCanvas = document.getElementById('collageCanvas');
        collageCtx = collageCanvas.getContext('2d');
        collageCanvas.width = 500;
        collageCanvas.height = 500;
        
        // ê¸°ë³¸ ëª¨ë“œ ì„ íƒ í‘œì‹œ
        selectCollageMode('horizontal');
        
        document.getElementById('collageUpload').onchange = async function(e) {
            const files = Array.from(e.target.files);
            if (collageImages_arr.length + files.length > 10) {
                alert('ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!');
                return;
            }
            
            // ëª¨ë“  ì´ë¯¸ì§€ ë¡œë”©ì„ Promiseë¡œ ê´€ë¦¬
            const loadPromises = files.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        const img = new Image();
                        img.onload = function() {
                            resolve({
                                img: img,
                                name: file.name,
                                size: (file.size / 1024).toFixed(1) + ' KB',
                                scale: 1.0,
                                x: 0,
                                y: 0
                            });
                        };
                        img.onerror = reject;
                        img.src = ev.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            });
            
            try {
                // ëª¨ë“  ì´ë¯¸ì§€ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
                const loadedImages = await Promise.all(loadPromises);
                
                // í•œ ë²ˆì— ë°°ì—´ì— ì¶”ê°€
                collageImages_arr.push(...loadedImages);
                
                // ëª¨ë‘ ë¡œë“œëœ í›„ì— UI ì—…ë°ì´íŠ¸
                updateCollagePreview();
            } catch (error) {
                console.error('ì´ë¯¸ì§€ ë¡œë”© ì˜¤ë¥˜:', error);
                alert('ì¼ë¶€ ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
            
            e.target.value = '';
        };
        
        document.getElementById('collageGap').oninput = function() {
            document.getElementById('collageGapValue').textContent = this.value + 'px';
            createCollage();
        };
        
        // í„°ì¹˜ ì´ë²¤íŠ¸ ì¶”ê°€
        setupCollageTouch();
    }
    
    function selectCollageMode(mode, evt) {
        collageMode = mode;
        
        // ëª¨ë“  ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
        ['collageFreeform', 'collageHorizontal', 'collageVertical', 'collageGrid', 'collageMain_sub', 'collageHalf_vertical', 'collageL_shape', 'collageT_shape', 'collageStairs'].forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.style.border = '3px solid #ddd';
                btn.style.transform = 'scale(1)';
            }
        });
        
        // ì„ íƒëœ ë²„íŠ¼ ê°•ì¡° (evt ìš°ì„ , ì—†ìœ¼ë©´ IDë¡œ ì°¾ê¸°)
        const e = evt || (typeof event !== 'undefined' ? event : null);
        const modeCapitalized = mode.charAt(0).toUpperCase() + mode.slice(1);
        const selectedBtn = (e && e.currentTarget) ? e.currentTarget : document.getElementById('collage' + modeCapitalized);
        if (selectedBtn) {
            selectedBtn.style.border = '3px solid #11593F';
            selectedBtn.style.transform = 'scale(1.05)';
            selectedBtn.style.boxShadow = '0 4px 12px rgba(17, 89, 63, 0.3)';
        }
        
        createCollage();
    }
    
    // ì½œë¼ì£¼ í„°ì¹˜ ì´ë²¤íŠ¸ ë³€ìˆ˜
    let collageSelectedImageIndex = -1;
    let collagePinchStartDistance = 0;
    let collageIsPinching = false;
    let collageDragging = false;
    let collageDragStartX = 0;
    let collageDragStartY = 0;
    
    function setupCollageTouch() {
        const canvas = collageCanvas;
        
        // í„°ì¹˜ ì‹œì‘
        canvas.addEventListener('touchstart', function(e) {
            if (collageImages_arr.length === 0) return;
            
            if (e.touches.length === 1) {
                // ë‹¨ì¼ í„°ì¹˜ - ì´ë¯¸ì§€ ì„ íƒ ë° ë“œë˜ê·¸ ì¤€ë¹„
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touchX = (e.touches[0].clientX - rect.left) * scaleX;
                const touchY = (e.touches[0].clientY - rect.top) * scaleY;
                
                // í„°ì¹˜í•œ ìœ„ì¹˜ì˜ ì´ë¯¸ì§€ ì°¾ê¸°
                let foundIndex = -1;
                for (let i = collageImages_arr.length - 1; i >= 0; i--) {
                    const item = collageImages_arr[i];
                    if (touchX >= item.x && touchX <= item.x + item.displayW &&
                        touchY >= item.y && touchY <= item.y + item.displayH) {
                        foundIndex = i;
                        break;
                    }
                }
                
                if (foundIndex !== -1) {
                    collageSelectedImageIndex = foundIndex;
                    collageDragging = true;
                    collageDragStartX = touchX;
                    collageDragStartY = touchY;
                    createCollage();
                }
            } else if (e.touches.length === 2 && collageSelectedImageIndex !== -1) {
                // í•€ì¹˜ ì‹œì‘
                e.preventDefault();
                collageDragging = false;
                collageIsPinching = true;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                collagePinchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });
        
        // í„°ì¹˜ ì´ë™
        canvas.addEventListener('touchmove', function(e) {
            if (collageIsPinching && e.touches.length === 2 && collageSelectedImageIndex !== -1) {
                e.preventDefault();
                
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (collagePinchStartDistance > 0) {
                    const scaleChange = currentDistance / collagePinchStartDistance;
                    const item = collageImages_arr[collageSelectedImageIndex];
                    const newScale = Math.max(0.3, Math.min(3.0, (item.scale || 1) * scaleChange));
                    item.scale = newScale;
                    
                    collagePinchStartDistance = currentDistance;
                    if (collageRafId) cancelAnimationFrame(collageRafId);
                    collageRafId = requestAnimationFrame(function() {
                        collageRafId = null;
                        createCollage();
                    });
                }
            } else if (collageDragging && e.touches.length === 1 && collageSelectedImageIndex !== -1 && collageMode === 'freeform') {
                // ììœ  ë°°ì¹˜ ëª¨ë“œì—ì„œë§Œ ë“œë˜ê·¸ ê°€ëŠ¥
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touchX = (e.touches[0].clientX - rect.left) * scaleX;
                const touchY = (e.touches[0].clientY - rect.top) * scaleY;
                
                const item = collageImages_arr[collageSelectedImageIndex];
                item.x += touchX - collageDragStartX;
                item.y += touchY - collageDragStartY;
                
                collageDragStartX = touchX;
                collageDragStartY = touchY;
                if (collageRafId) cancelAnimationFrame(collageRafId);
                collageRafId = requestAnimationFrame(function() {
                    collageRafId = null;
                    createCollage();
                });
            }
        }, { passive: false });
        
        // í„°ì¹˜ ì¢…ë£Œ
        canvas.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                collageIsPinching = false;
                collagePinchStartDistance = 0;
            }
            if (e.touches.length === 0) {
                collageDragging = false;
            }
        });
        
        canvas.addEventListener('touchcancel', function() {
            collageIsPinching = false;
            collagePinchStartDistance = 0;
            collageDragging = false;
        });
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë„ ì§€ì› (PCì—ì„œ í…ŒìŠ¤íŠ¸ìš©)
        canvas.addEventListener('mousedown', function(e) {
            if (collageImages_arr.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            let foundIndex = -1;
            for (let i = collageImages_arr.length - 1; i >= 0; i--) {
                const item = collageImages_arr[i];
                if (mouseX >= item.x && mouseX <= item.x + item.displayW &&
                    mouseY >= item.y && mouseY <= item.y + item.displayH) {
                    foundIndex = i;
                    break;
                }
            }
            
            if (foundIndex !== -1) {
                collageSelectedImageIndex = foundIndex;
                collageDragging = true;
                collageDragStartX = mouseX;
                collageDragStartY = mouseY;
                createCollage();
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (collageDragging && collageSelectedImageIndex !== -1 && collageMode === 'freeform') {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                const item = collageImages_arr[collageSelectedImageIndex];
                item.x += mouseX - collageDragStartX;
                item.y += mouseY - collageDragStartY;
                
                collageDragStartX = mouseX;
                collageDragStartY = mouseY;
                if (collageRafId) cancelAnimationFrame(collageRafId);
                collageRafId = requestAnimationFrame(function() {
                    collageRafId = null;
                    createCollage();
                });
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            collageDragging = false;
        });
        
        // ë§ˆìš°ìŠ¤ íœ ë¡œ í¬ê¸° ì¡°ì ˆ
        canvas.addEventListener('wheel', function(e) {
            if (collageSelectedImageIndex !== -1) {
                e.preventDefault();
                const item = collageImages_arr[collageSelectedImageIndex];
                const delta = e.deltaY > 0 ? 0.95 : 1.05;
                const newScale = Math.max(0.3, Math.min(3.0, (item.scale || 1) * delta));
                item.scale = newScale;
                createCollage();
            }
        }, { passive: false });
    }

    function escapeHtml(str) {
        if (!str) return '';
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
    
    function updateCollagePreview() {
        const list = document.getElementById('collagePreviewList');
        list.innerHTML = '';
        
        collageImages_arr.forEach((item, idx) => {
            const div = document.createElement('div');
            div.className = 'image-preview-item';
            div.innerHTML = `
                <img src="${item.img.src}" class="preview-thumb">
                <div class="preview-info">
                    <div class="preview-name">${escapeHtml(item.name)}</div>
                    <div class="preview-size">${escapeHtml(item.size)}</div>
                </div>
                <button class="delete-preview-btn" onclick="deleteCollageImage(${idx})">ì‚­ì œ</button>
            `;
            list.appendChild(div);
        });
        
        // ì´ë¯¸ì§€ê°€ ì¶”ê°€ë˜ë©´ ìë™ìœ¼ë¡œ ì½œë¼ì£¼ ìƒì„±
        createCollage();
    }

    function deleteCollageImage(idx) {
        collageImages_arr.splice(idx, 1);
        updateCollagePreview();
        createCollage();
    }

    function createCollage() {
        if (collageImages_arr.length === 0) return;
        
        const gap = parseInt(document.getElementById('collageGap').value);
        
        if (collageMode === 'horizontal') {
            let totalW = 0;
            let maxH = 0;
            collageImages_arr.forEach(item => {
                const scaledW = item.img.width * (item.scale || 1);
                const scaledH = item.img.height * (item.scale || 1);
                totalW += scaledW;
                maxH = Math.max(maxH, scaledH);
            });
            totalW += gap * (collageImages_arr.length - 1);
            
            collageCanvas.width = totalW;
            collageCanvas.height = maxH;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, collageCanvas.width, collageCanvas.height);
            
            let x = 0;
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                const w = item.img.width * scale;
                const h = item.img.height * scale;
                const y = (maxH - h) / 2;
                
                // ì´ë¯¸ì§€ ìœ„ì¹˜ ì €ì¥ (í„°ì¹˜ ì„ íƒìš©)
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                collageCtx.drawImage(item.img, x, y, w, h);
                
                // ì„ íƒëœ ì´ë¯¸ì§€ í‘œì‹œ
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
                
                x += w + gap;
            });
        } else if (collageMode === 'vertical') {
            let maxW = 0;
            let totalH = 0;
            collageImages_arr.forEach(item => {
                const scaledW = item.img.width * (item.scale || 1);
                const scaledH = item.img.height * (item.scale || 1);
                maxW = Math.max(maxW, scaledW);
                totalH += scaledH;
            });
            totalH += gap * (collageImages_arr.length - 1);
            
            collageCanvas.width = maxW;
            collageCanvas.height = totalH;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, collageCanvas.width, collageCanvas.height);
            
            let y = 0;
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                const w = item.img.width * scale;
                const h = item.img.height * scale;
                const x = (maxW - w) / 2;
                
                // ì´ë¯¸ì§€ ìœ„ì¹˜ ì €ì¥
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                collageCtx.drawImage(item.img, x, y, w, h);
                
                // ì„ íƒëœ ì´ë¯¸ì§€ í‘œì‹œ
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
                
                y += h + gap;
            });
        } else if (collageMode === 'grid') {
            const cols = Math.ceil(Math.sqrt(collageImages_arr.length));
            const rows = Math.ceil(collageImages_arr.length / cols);
            
            // ëª¨ë“  ì´ë¯¸ì§€ë¥¼ ì •ì‚¬ê°í˜• ì¹¸ì— ë§ì¶”ê¸° (ì°Œê·¸ëŸ¬ì§ ë°©ì§€)
            const cellSize = 300; // ê³ ì • ì¹¸ í¬ê¸°
            
            collageCanvas.width = cellSize * cols + gap * (cols - 1);
            collageCanvas.height = cellSize * rows + gap * (rows - 1);
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, collageCanvas.width, collageCanvas.height);
            
            collageImages_arr.forEach((item, idx) => {
                const col = idx % cols;
                const row = Math.floor(idx / cols);
                const cellX = col * (cellSize + gap);
                const cellY = row * (cellSize + gap);
                
                // object-fit: cover ë°©ì‹ - ì¹¸ì„ ê½‰ ì±„ìš°ë˜ ë¹„ìœ¨ ìœ ì§€
                const imgRatio = item.img.width / item.img.height;
                const cellRatio = 1; // ì •ì‚¬ê°í˜•
                
                let drawW, drawH, drawX, drawY;
                let sourceX = 0, sourceY = 0, sourceW = item.img.width, sourceH = item.img.height;
                
                if (imgRatio > cellRatio) {
                    // ì´ë¯¸ì§€ê°€ ë” ë„“ìŒ -> ë†’ì´ ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê³  ì¢Œìš° ìë¥´ê¸°
                    const cropWidth = item.img.height * cellRatio;
                    sourceX = (item.img.width - cropWidth) / 2;
                    sourceW = cropWidth;
                } else {
                    // ì´ë¯¸ì§€ê°€ ë” ë†’ìŒ -> ë„ˆë¹„ ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê³  ìƒí•˜ ìë¥´ê¸°
                    const cropHeight = item.img.width / cellRatio;
                    sourceY = (item.img.height - cropHeight) / 2;
                    sourceH = cropHeight;
                }
                
                // ì¹¸ì— ê½‰ ì°¨ê²Œ ê·¸ë¦¬ê¸°
                drawX = cellX;
                drawY = cellY;
                drawW = cellSize;
                drawH = cellSize;
                
                // ì´ë¯¸ì§€ ìœ„ì¹˜ ì €ì¥
                item.x = drawX;
                item.y = drawY;
                item.displayW = drawW;
                item.displayH = drawH;
                
                collageCtx.drawImage(
                    item.img,
                    sourceX, sourceY, sourceW, sourceH,
                    drawX, drawY, drawW, drawH
                );
                
                // ì„ íƒëœ ì´ë¯¸ì§€ í‘œì‹œ
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(drawX - 2, drawY - 2, drawW + 4, drawH + 4);
                }
            });
        } else if (collageMode === 'freeform') {
            // ììœ  ë°°ì¹˜ ëª¨ë“œ
            collageCanvas.width = 800;
            collageCanvas.height = 800;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, collageCanvas.width, collageCanvas.height);
            
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 0.3;
                const w = item.img.width * scale;
                const h = item.img.height * scale;
                
                // ìœ„ì¹˜ ì´ˆê¸°í™” (ì²˜ìŒ ì¶”ê°€ëœ ê²½ìš°)
                if (item.x === undefined || item.y === undefined) {
                    item.x = Math.random() * (collageCanvas.width - w);
                    item.y = Math.random() * (collageCanvas.height - h);
                }
                
                item.displayW = w;
                item.displayH = h;
                
                collageCtx.drawImage(item.img, item.x, item.y, w, h);
                
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(item.x - 2, item.y - 2, w + 4, h + 4);
                }
            });
        } else if (collageMode === 'main_sub') {
            // ë©”ì¸+ì„œë¸Œ (í° ì‚¬ì§„ 1ê°œ + ì‘ì€ ì‚¬ì§„ 3ê°œ)
            const canvasSize = 800;
            collageCanvas.width = canvasSize;
            collageCanvas.height = canvasSize;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, canvasSize, canvasSize);
            
            const mainSize = canvasSize - gap;
            const subSize = (canvasSize - gap * 4) / 3;
            
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                let x, y, w, h;
                
                if (idx === 0) {
                    // ë©”ì¸ ì´ë¯¸ì§€ (ì™¼ìª½ í° ì‚¬ì§„)
                    w = mainSize * 0.65 * scale;
                    h = mainSize * scale;
                    x = gap;
                    y = gap;
                } else {
                    // ì„œë¸Œ ì´ë¯¸ì§€ (ì˜¤ë¥¸ìª½ ì‘ì€ ì‚¬ì§„ 3ê°œ)
                    w = mainSize * 0.3 * scale;
                    h = subSize * scale;
                    x = gap + mainSize * 0.65 + gap;
                    y = gap + (idx - 1) * (subSize + gap);
                }
                
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                const imgScale = Math.max(w / item.img.width, h / item.img.height);
                const imgW = item.img.width * imgScale;
                const imgH = item.img.height * imgScale;
                
                collageCtx.drawImage(item.img, x + (w - imgW) / 2, y + (h - imgH) / 2, imgW, imgH);
                
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
            });
        } else if (collageMode === 'half_vertical') {
            // ë°˜ë°˜ ì„¸ë¡œ (ì™¼ìª½ 1ê°œ í° ì‚¬ì§„, ì˜¤ë¥¸ìª½ 2ê°œ ì‘ì€ ì‚¬ì§„)
            const canvasSize = 800;
            collageCanvas.width = canvasSize;
            collageCanvas.height = canvasSize;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, canvasSize, canvasSize);
            
            const halfW = (canvasSize - gap * 3) / 2;
            const halfH = (canvasSize - gap * 3) / 2;
            
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                let x, y, w, h;
                
                if (idx === 0) {
                    // ì™¼ìª½ í° ì‚¬ì§„
                    w = halfW * scale;
                    h = (canvasSize - gap * 2) * scale;
                    x = gap;
                    y = gap;
                } else if (idx === 1) {
                    // ì˜¤ë¥¸ìª½ ìœ„ ì‘ì€ ì‚¬ì§„
                    w = halfW * scale;
                    h = halfH * scale;
                    x = gap * 2 + halfW;
                    y = gap;
                } else if (idx === 2) {
                    // ì˜¤ë¥¸ìª½ ì•„ë˜ ì‘ì€ ì‚¬ì§„
                    w = halfW * scale;
                    h = halfH * scale;
                    x = gap * 2 + halfW;
                    y = gap * 2 + halfH;
                }
                
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                const imgScale = Math.max(w / item.img.width, h / item.img.height);
                const imgW = item.img.width * imgScale;
                const imgH = item.img.height * imgScale;
                
                collageCtx.drawImage(item.img, x + (w - imgW) / 2, y + (h - imgH) / 2, imgW, imgH);
                
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
            });
        } else if (collageMode === 'l_shape') {
            // Lìí˜• (ìœ„ 1ê°œ í° ì‚¬ì§„, ì•„ë˜ 2ê°œ ì‘ì€ ì‚¬ì§„)
            const canvasSize = 800;
            collageCanvas.width = canvasSize;
            collageCanvas.height = canvasSize;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, canvasSize, canvasSize);
            
            const topH = (canvasSize - gap * 3) * 0.65;
            const bottomH = (canvasSize - gap * 3) * 0.35;
            const halfW = (canvasSize - gap * 3) / 2;
            
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                let x, y, w, h;
                
                if (idx === 0) {
                    // ìœ„ í° ì‚¬ì§„
                    w = (canvasSize - gap * 2) * scale;
                    h = topH * scale;
                    x = gap;
                    y = gap;
                } else if (idx === 1) {
                    // ì•„ë˜ ì™¼ìª½ ì‘ì€ ì‚¬ì§„
                    w = halfW * scale;
                    h = bottomH * scale;
                    x = gap;
                    y = gap * 2 + topH;
                } else if (idx === 2) {
                    // ì•„ë˜ ì˜¤ë¥¸ìª½ ì‘ì€ ì‚¬ì§„
                    w = halfW * scale;
                    h = bottomH * scale;
                    x = gap * 2 + halfW;
                    y = gap * 2 + topH;
                }
                
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                const imgScale = Math.max(w / item.img.width, h / item.img.height);
                const imgW = item.img.width * imgScale;
                const imgH = item.img.height * imgScale;
                
                collageCtx.drawImage(item.img, x + (w - imgW) / 2, y + (h - imgH) / 2, imgW, imgH);
                
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
            });
        } else if (collageMode === 't_shape') {
            // Tìí˜• (ìœ„ 3ê°œ ì‘ì€ ì‚¬ì§„, ì•„ë˜ 1ê°œ í° ì‚¬ì§„)
            const canvasSize = 800;
            collageCanvas.width = canvasSize;
            collageCanvas.height = canvasSize;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, canvasSize, canvasSize);
            
            const topH = (canvasSize - gap * 3) * 0.35;
            const bottomH = (canvasSize - gap * 3) * 0.65;
            const thirdW = (canvasSize - gap * 4) / 3;
            
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                let x, y, w, h;
                
                if (idx < 3) {
                    // ìœ„ 3ê°œ ì‘ì€ ì‚¬ì§„
                    w = thirdW * scale;
                    h = topH * scale;
                    x = gap + idx * (thirdW + gap);
                    y = gap;
                } else {
                    // ì•„ë˜ 1ê°œ í° ì‚¬ì§„
                    w = (canvasSize - gap * 2) * scale;
                    h = bottomH * scale;
                    x = gap;
                    y = gap * 2 + topH;
                }
                
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                const imgScale = Math.max(w / item.img.width, h / item.img.height);
                const imgW = item.img.width * imgScale;
                const imgH = item.img.height * imgScale;
                
                collageCtx.drawImage(item.img, x + (w - imgW) / 2, y + (h - imgH) / 2, imgW, imgH);
                
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
            });
        } else if (collageMode === 'stairs') {
            // ê³„ë‹¨í˜• (ëŒ€ê°ì„  ë°°ì¹˜)
            const canvasSize = 800;
            collageCanvas.width = canvasSize;
            collageCanvas.height = canvasSize;
            collageCtx.fillStyle = '#ffffff';
            collageCtx.fillRect(0, 0, canvasSize, canvasSize);
            
            const cellSize = (canvasSize - gap * 4) / 3;
            
            collageImages_arr.forEach((item, idx) => {
                const scale = item.scale || 1;
                const w = cellSize * scale;
                const h = cellSize * scale;
                const x = gap + idx * (cellSize + gap);
                const y = gap + idx * (cellSize + gap);
                
                if (idx >= 3) return; // ìµœëŒ€ 3ê°œë§Œ
                
                item.x = x;
                item.y = y;
                item.displayW = w;
                item.displayH = h;
                
                const imgScale = Math.max(w / item.img.width, h / item.img.height);
                const imgW = item.img.width * imgScale;
                const imgH = item.img.height * imgScale;
                
                collageCtx.drawImage(item.img, x + (w - imgW) / 2, y + (h - imgH) / 2, imgW, imgH);
                
                if (idx === collageSelectedImageIndex) {
                    collageCtx.strokeStyle = '#11593F';
                    collageCtx.lineWidth = 4;
                    collageCtx.strokeRect(x - 2, y - 2, w + 4, h + 4);
                }
            });
        }
    }

    function downloadCollageImage() {
        if (collageImages_arr.length === 0) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // ì½œë¼ì£¼ê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ë¨¼ì € ìƒì„±
        if (collageCanvas.width === 500 && collageCanvas.height === 500) {
            createCollage();
        }
        
        try {
            collageCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `í˜¸ì†Œì¸_${getFormattedDate()}_ì¸ìŠ¤íƒ€ì‚¬ì´ì¦ˆ_1.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
        } catch (error) {
            console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
            alert('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }

    // ===== 4. ì´ë¯¸ì§€ ê¾¸ë¯¸ê¸° ê¸°ëŠ¥ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€) =====
    let decorateCanvas, decorateCtx;
    let decorateInitialized = false;
    let decorateImg = new Image();
    let decorateScale = 1, decorateOriginX = 0, decorateOriginY = 0;
    let decorateIsDragging = false, decorateStartX, decorateStartY;
    let lastPinchDistance = 0;
    let isPinching = false;
    let texts = [], stickers = [];
    let selectedTextIndex = -1, selectedStickerIndex = -1;
    let mode = 'arrange';
    let originX = 0, originY = 0, scale = 1;
    
    // ì‹¤í–‰ ì·¨ì†Œ/ë‹¤ì‹œ ì‹¤í–‰ìš© íˆìŠ¤í† ë¦¬
    let decorateHistory = [];
    let decorateHistoryIndex = -1;
    const MAX_HISTORY = 50;

    function initDecorate() {
        if (decorateInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        decorateInitialized = true;
        
        decorateCanvas = document.getElementById('decorateCanvas');
        decorateCtx = decorateCanvas.getContext('2d', { willReadFrequently: true });
        decorateCanvas.width = 500;
        decorateCanvas.height = 500;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        setupDecorateEvents();
        updateWidgetPlaceholder();
        drawDecorate();
    }

    function setupDecorateEvents() {
        document.getElementById('decorateUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                decorateImg.src = ev.target.result;
                decorateImg.onload = function() {
                    const maxSize = 800;
                    if (decorateImg.width > decorateImg.height) {
                        decorateCanvas.width = maxSize;
                        decorateCanvas.height = maxSize * (decorateImg.height / decorateImg.width);
                    } else {
                        decorateCanvas.height = maxSize;
                        decorateCanvas.width = maxSize * (decorateImg.width / decorateImg.height);
                    }
                    decorateOriginX = 0;
                    decorateOriginY = 0;
                    decorateScale = Math.min(decorateCanvas.width / decorateImg.width, decorateCanvas.height / decorateImg.height);
                    
                    // ì´ˆê¸° ìƒíƒœë¡œ íˆìŠ¤í† ë¦¬ ë¦¬ì…‹ ë° ì €ì¥
                    texts = [];
                    stickers = [];
                    decorateHistory = [];
                    decorateHistoryIndex = -1;
                    saveHistory();
                    
                    drawDecorate();
                };
            };
            reader.readAsDataURL(file);
        };

        document.getElementById('stickerUpload').onchange = async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const stickerData = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        const sImg = new Image();
                        sImg.onload = function() {
                            resolve({
                                img: sImg,
                                x: decorateCanvas.width/2,
                                y: decorateCanvas.height/2,
                                width: sImg.width,
                                height: sImg.height,
                                scale: 0.5,
                                borderColor: '#000',
                                borderWidth: 0
                            });
                        };
                        sImg.onerror = reject;
                        sImg.src = ev.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
                
                // ì´ë¯¸ì§€ê°€ ì™„ì „íˆ ë¡œë“œëœ í›„ì— ì¶”ê°€
                stickers.push(stickerData);
                saveHistory(); // íˆìŠ¤í† ë¦¬ ì €ì¥
                drawDecorate();
            } catch (error) {
                console.error('ìŠ¤í‹°ì»¤ ë¡œë”© ì˜¤ë¥˜:', error);
                alert('ìŠ¤í‹°ì»¤ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
            
            e.target.value = '';
        };

        ['overlaySelect', 'radiusSlider', 'shadowSlider', 'opacitySlider'].forEach(id => {
            document.getElementById(id).oninput = drawDecorate;
        });

        document.getElementById('itemBorderColor').oninput = function() {
            if (selectedStickerIndex !== -1) {
                stickers[selectedStickerIndex].borderColor = this.value;
                drawDecorate();
            }
        };

        applyMagnetic(document.getElementById('itemScale'), () => {
            const s = parseInt(document.getElementById('itemScale').value) / 100;
            if (selectedStickerIndex !== -1) stickers[selectedStickerIndex].scale = s;
            if (selectedTextIndex !== -1) texts[selectedTextIndex].scale = s;
        });

        applyMagnetic(document.getElementById('itemBorderWidth'), () => {
            if (selectedStickerIndex !== -1) {
                stickers[selectedStickerIndex].borderWidth = parseInt(document.getElementById('itemBorderWidth').value);
            }
        });

        decorateCanvas.addEventListener('mousedown', decorateStartInteract);
        decorateCanvas.addEventListener('touchstart', decorateStartInteract, {passive: false});
        ['mousemove', 'touchmove'].forEach(evt => decorateCanvas.addEventListener(evt, decorateMove, {passive: false}));
        ['mouseup', 'touchend', 'mouseleave', 'touchcancel'].forEach(evt => decorateCanvas.addEventListener(evt, decorateEndInteract));
        decorateCanvas.addEventListener('wheel', decorateWheel, {passive: false});
    }

    function drawDecorate() {
        if (decorateCanvas.width === 0) return;
        
        decorateCtx.fillStyle = '#ffffff';
        decorateCtx.fillRect(0, 0, decorateCanvas.width, decorateCanvas.height);

        if (decorateImg.src) {
            decorateCtx.save();
            const shadowVal = parseInt(document.getElementById('shadowSlider').value);
            const radius = parseInt(document.getElementById('radiusSlider').value);
            
            decorateCtx.translate(decorateOriginX, decorateOriginY);
            decorateCtx.scale(decorateScale, decorateScale);

            if (shadowVal > 0) {
                decorateCtx.shadowColor = "rgba(0,0,0,0.3)";
                decorateCtx.shadowBlur = shadowVal;
                decorateCtx.shadowOffsetX = shadowVal/2;
                decorateCtx.shadowOffsetY = shadowVal/2;
            }
            if (radius > 0) {
                decorateCtx.beginPath();
                decorateCtx.roundRect(0, 0, decorateImg.width, decorateImg.height, radius);
                decorateCtx.clip();
            }
            decorateCtx.drawImage(decorateImg, 0, 0);
            decorateCtx.restore();

            drawOverlay(decorateImg.width, decorateImg.height);
        }

        stickers.forEach((s, i) => {
            decorateCtx.save();
            decorateCtx.translate(s.x, s.y);
            decorateCtx.scale(s.scale, s.scale);
            const ox = -s.width/2;
            const oy = -s.height/2;

            if (s.borderWidth > 0) {
                decorateCtx.strokeStyle = s.borderColor;
                decorateCtx.lineWidth = s.borderWidth / s.scale;
                decorateCtx.lineJoin = "round";
                decorateCtx.strokeRect(ox, oy, s.width, s.height);
            }
            decorateCtx.drawImage(s.img, ox, oy, s.width, s.height);

            if (i === selectedStickerIndex) {
                decorateCtx.strokeStyle = "#FF5722";
                decorateCtx.lineWidth = 3/s.scale;
                decorateCtx.setLineDash([6, 6]);
                decorateCtx.strokeRect(ox - 5/s.scale, oy - 5/s.scale, s.width + 10/s.scale, s.height + 10/s.scale);
                decorateCtx.setLineDash([]);
            }
            decorateCtx.restore();
        });

        texts.forEach((t, i) => {
            decorateCtx.save();
            
            // í°íŠ¸ ì„¤ì • (ì‚¬ìš©ì ì„ íƒ í°íŠ¸ ë˜ëŠ” ê¸°ë³¸)
            const fontFamily = t.font || "'Pretendard', sans-serif";
            const fontWeight = (t.effect === 'bold') ? '900' : 'bold';
            decorateCtx.font = `${fontWeight} ${t.size}px ${fontFamily}`;
            decorateCtx.textAlign = "center";
            decorateCtx.textBaseline = "middle";
            decorateCtx.translate(t.x, t.y);
            decorateCtx.scale(t.scale, t.scale);

            // íš¨ê³¼ ì ìš©
            const effect = t.effect || 'none';
            
            if (effect === 'shadow') {
                // ê·¸ë¦¼ì íš¨ê³¼
                decorateCtx.shadowColor = "rgba(0,0,0,0.7)";
                decorateCtx.shadowBlur = 8;
                decorateCtx.shadowOffsetX = 4;
                decorateCtx.shadowOffsetY = 4;
                decorateCtx.fillStyle = t.color || "#ffffff";
                decorateCtx.fillText(t.content, 0, 0);
                
            } else if (effect === 'outline') {
                // í…Œë‘ë¦¬ íš¨ê³¼ (ë” êµµê²Œ)
                decorateCtx.strokeStyle = "#000000";
                decorateCtx.lineWidth = t.size / 10;
                decorateCtx.lineJoin = "round";
                decorateCtx.strokeText(t.content, 0, 0);
                decorateCtx.fillStyle = t.color || "#ffffff";
                decorateCtx.fillText(t.content, 0, 0);
                
            } else if (effect === 'glow') {
                // ë°œê´‘ íš¨ê³¼
                decorateCtx.shadowColor = t.color || "#ffffff";
                decorateCtx.shadowBlur = 20;
                decorateCtx.fillStyle = t.color || "#ffffff";
                decorateCtx.fillText(t.content, 0, 0);
                decorateCtx.shadowBlur = 10;
                decorateCtx.fillText(t.content, 0, 0);
                decorateCtx.shadowBlur = 0;
                decorateCtx.fillText(t.content, 0, 0);
                
            } else if (effect === 'bold') {
                // ë‘ê»ê²Œ íš¨ê³¼ (ì—¬ëŸ¬ ë²ˆ ê²¹ì³ ê·¸ë¦¬ê¸°)
                decorateCtx.fillStyle = t.color || "#ffffff";
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        decorateCtx.fillText(t.content, dx, dy);
                    }
                }
                
            } else {
                // ê¸°ë³¸ (íš¨ê³¼ ì—†ìŒ)
                decorateCtx.fillStyle = t.color || "#ffffff";
                decorateCtx.fillText(t.content, 0, 0);
            }
            
            // ì„ íƒëœ í…ìŠ¤íŠ¸ í‘œì‹œ
            if (i === selectedTextIndex) {
                decorateCtx.strokeStyle = "#F27405";
                decorateCtx.lineWidth = 3;
                decorateCtx.setLineDash([6, 6]);
                const metrics = decorateCtx.measureText(t.content);
                const textWidth = metrics.width;
                const textHeight = t.size;
                decorateCtx.strokeRect(-textWidth/2 - 10, -textHeight/2 - 5, textWidth + 20, textHeight + 10);
                decorateCtx.setLineDash([]);
            }
            
            decorateCtx.restore();
        });
    }

    function drawPattern() {
        // íŒ¨í„´ ê¸°ëŠ¥ ì œê±°ë¨
    }

    function drawOverlay(w, h) {
        const overlayMode = document.getElementById('overlaySelect').value;
        if (overlayMode === 'none') return;
        const opacity = parseInt(document.getElementById('opacitySlider').value) / 100;
        
        decorateCtx.save();
        decorateCtx.globalAlpha = opacity;
        decorateCtx.translate(decorateOriginX, decorateOriginY);
        decorateCtx.scale(decorateScale, decorateScale);
        
        if (overlayMode.includes('gradient')) {
            const grad = decorateCtx.createLinearGradient(0, 0, 0, h);
            const color = overlayMode === 'gradient-black' ? '0,0,0' : '255,255,255';
            grad.addColorStop(0, `rgba(${color}, 0)`);
            grad.addColorStop(1, `rgba(${color}, 1)`);
            decorateCtx.fillStyle = grad;
        } else {
            decorateCtx.fillStyle = overlayMode === 'black' ? '#000' : '#fff';
        }
        decorateCtx.fillRect(0, 0, w, h);
        decorateCtx.restore();
    }

    function toggleMode(newMode) {
        mode = newMode;
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`btn-${newMode}`).classList.add('active');
        
        selectedStickerIndex = -1;
        selectedTextIndex = -1;
        document.getElementById('selectedItemPanel').style.display = 'none';
        drawDecorate();
    }

    function applyMagnetic(slider, callback) {
        slider.oninput = () => {
            let val = parseInt(slider.value);
            if (Math.abs(val - 50) < 3) val = 50;
            if (Math.abs(val - 100) < 3) val = 100;
            if (Math.abs(val - 0) < 3) val = 0;
            slider.value = val;
            if (callback) callback();
            drawDecorate();
        };
    }

    window.createWidget = function() {
        const type = document.getElementById('widgetType').value;
        const t1 = document.getElementById('widgetInput1').value;
        const t2 = document.getElementById('widgetInput2').value;
        
        const wc = document.createElement('canvas');
        const wctx = wc.getContext('2d');
        let w = 300, h = 80;

        if(type === 'noti') {
            w = 340; h = 80;
            wc.width = w; wc.height = h;
            wctx.fillStyle = "rgba(255,255,255,0.95)";
            wctx.roundRect(0, 0, w, h, 16);
            wctx.fill();
            wctx.font = "30px serif";
            wctx.fillText("ğŸ””", 20, 50);
            wctx.fillStyle = "#000";
            wctx.font = "bold 15px 'Noto Sans KR', sans-serif";
            wctx.fillText(t1 || "ì•Œë¦¼", 60, 35);
            wctx.fillStyle = "#555";
            wctx.font = "14px 'Noto Sans KR', sans-serif";
            wctx.fillText(t2 || "ë‚´ìš© ì—†ìŒ", 60, 58);
            wctx.fillStyle = "#999";
            wctx.font = "12px 'Noto Sans KR', sans-serif";
            wctx.fillText("ì§€ê¸ˆ", w - 40, 35);
        } else if(type === 'music') {
            w = 300; h = 90;
            wc.width = w; wc.height = h;
            wctx.fillStyle = "rgba(0,0,0,0.75)";
            wctx.roundRect(0, 0, w, h, 16);
            wctx.fill();
            wctx.fillStyle = "#1a1a1a";
            wctx.fillRect(15, 15, 60, 60);
            wctx.font = "30px serif";
            wctx.fillText("ğŸ’¿", 30, 55);
            wctx.fillStyle = "#fff";
            wctx.font = "bold 16px 'Noto Sans KR', sans-serif";
            wctx.fillText(t2 || "ë…¸ë˜ ì œëª©", 90, 38);
            wctx.fillStyle = "#ccc";
            wctx.font = "13px 'Noto Sans KR', sans-serif";
            wctx.fillText(t1 || "ê°€ìˆ˜ëª…", 90, 58);
        } else if(type === 'location') {
            w = 240; h = 44;
            wc.width = w; wc.height = h;
            wctx.fillStyle = "rgba(255,255,255,0.95)";
            wctx.roundRect(0, 0, w, h, 10);
            wctx.fill();
            wctx.font = "20px serif";
            wctx.fillText("ğŸ“", 10, 30);
            wctx.fillStyle = "#0091ea";
            wctx.font = "bold 16px 'Noto Sans KR', sans-serif";
            wctx.fillText(t1 || "ìœ„ì¹˜ íƒœê·¸", 40, 28);
        }

        const simg = new Image();
        simg.onload = () => {
            stickers.push({
                img: simg,
                x: decorateCanvas.width/2,
                y: decorateCanvas.height/2,
                width: w,
                height: h,
                scale: 0.7,
                borderColor: '#000',
                borderWidth: 0
            });
            toggleMode('arrange');
            saveHistory(); // íˆìŠ¤í† ë¦¬ ì €ì¥
            drawDecorate();
        };
        simg.src = wc.toDataURL();
        document.getElementById('widgetInput1').value = "";
        document.getElementById('widgetInput2').value = "";
    };

    window.updateWidgetPlaceholder = function() {
        const type = document.getElementById('widgetType').value;
        const i1 = document.getElementById('widgetInput1');
        const i2 = document.getElementById('widgetInput2');
        if(type === 'noti') {
            i1.placeholder = "ë³´ë‚¸ì´";
            i2.placeholder = "ë‚´ìš©";
            i2.style.display = "block";
        } else if(type === 'music') {
            i1.placeholder = "ê°€ìˆ˜";
            i2.placeholder = "ì œëª©";
            i2.style.display = "block";
        } else if(type === 'location') {
            i1.placeholder = "ì¥ì†Œëª…";
            i2.style.display = "none";
        }
    };

    window.addText = function() {
        const input = document.getElementById('textInput');
        if(!input.value) {
            alert('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // í°íŠ¸ ì„ íƒì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì†ê¸€ì”¨ì²´ ì‚¬ìš©
        const fontFamily = document.getElementById('fontFamily') ? 
            document.getElementById('fontFamily').value : 
            'Nanum Pen Script, cursive';
        const size = parseInt(document.getElementById('textSize').value);
        const color = document.getElementById('textColor').value;
        const effect = document.getElementById('textEffect').value;
        
        texts.push({
            content: input.value,
            x: decorateCanvas.width/2,
            y: decorateCanvas.height/2,
            size: size,
            scale: 1,
            color: color,
            font: fontFamily,
            effect: effect
        });
        
        input.value = "";
        toggleMode('arrange');
        saveHistory(); // íˆìŠ¤í† ë¦¬ ì €ì¥
        drawDecorate();
    };
    
    // íˆìŠ¤í† ë¦¬ ê´€ë¦¬ í•¨ìˆ˜ë“¤
    function saveHistory() {
        // í˜„ì¬ ìœ„ì¹˜ ì´í›„ì˜ íˆìŠ¤í† ë¦¬ ì œê±°
        decorateHistory = decorateHistory.slice(0, decorateHistoryIndex + 1);
        
        // í˜„ì¬ ìƒíƒœ ì €ì¥
        decorateHistory.push({
            texts: JSON.parse(JSON.stringify(texts)),
            stickers: JSON.parse(JSON.stringify(stickers.map(s => ({
                x: s.x,
                y: s.y,
                width: s.width,
                height: s.height,
                scale: s.scale,
                borderColor: s.borderColor,
                borderWidth: s.borderWidth,
                src: s.img.src
            }))))
        });
        
        // ìµœëŒ€ íˆìŠ¤í† ë¦¬ ê°œìˆ˜ ì œí•œ
        if (decorateHistory.length > MAX_HISTORY) {
            decorateHistory.shift();
        } else {
            decorateHistoryIndex++;
        }
        
        updateUndoRedoButtons();
    }
    
    function undo() {
        if (decorateHistoryIndex > 0) {
            decorateHistoryIndex--;
            restoreHistory(decorateHistory[decorateHistoryIndex]);
        }
    }
    
    function redo() {
        if (decorateHistoryIndex < decorateHistory.length - 1) {
            decorateHistoryIndex++;
            restoreHistory(decorateHistory[decorateHistoryIndex]);
        }
    }
    
    function restoreHistory(state) {
        texts = JSON.parse(JSON.stringify(state.texts));
        
        // ìŠ¤í‹°ì»¤ ë³µì›
        stickers = [];
        state.stickers.forEach(s => {
            const img = new Image();
            img.onload = () => {
                stickers.push({
                    img: img,
                    x: s.x,
                    y: s.y,
                    width: s.width,
                    height: s.height,
                    scale: s.scale,
                    borderColor: s.borderColor,
                    borderWidth: s.borderWidth
                });
                drawDecorate();
            };
            img.src = s.src;
        });
        
        selectedTextIndex = -1;
        selectedStickerIndex = -1;
        document.getElementById('selectedItemPanel').style.display = 'none';
        updateUndoRedoButtons();
        drawDecorate();
    }
    
    function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        
        if (undoBtn) undoBtn.disabled = (decorateHistoryIndex <= 0);
        if (redoBtn) redoBtn.disabled = (decorateHistoryIndex >= decorateHistory.length - 1);
    }
    
    // í…ìŠ¤íŠ¸ í¬ê¸° ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸
    document.addEventListener('DOMContentLoaded', function() {
        const textSizeSlider = document.getElementById('textSize');
        if (textSizeSlider) {
            textSizeSlider.oninput = function() {
                document.getElementById('textSizeValue').textContent = this.value;
            };
        }
        
        // ëª¨ë“  inputê³¼ textarea ìš”ì†Œì— í¬ì»¤ìŠ¤ ì´ë²¤íŠ¸ ì¶”ê°€
        const allInputs = document.querySelectorAll('input[type="text"], input[type="number"], textarea');
        allInputs.forEach(input => {
            input.addEventListener('focus', function() {
                // ì§§ì€ ì§€ì—° í›„ ìŠ¤í¬ë¡¤ (í‚¤ë³´ë“œê°€ ì˜¬ë¼ì˜¤ëŠ” ì‹œê°„ ê³ ë ¤)
                setTimeout(() => {
                    this.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                }, 300);
            });
        });
    });

    window.deleteSelectedItem = function() {
        if(selectedStickerIndex !== -1) {
            stickers.splice(selectedStickerIndex, 1);
            selectedStickerIndex = -1;
        } else if(selectedTextIndex !== -1) {
            texts.splice(selectedTextIndex, 1);
            selectedTextIndex = -1;
        }
        document.getElementById('selectedItemPanel').style.display = 'none';
        saveHistory(); // íˆìŠ¤í† ë¦¬ ì €ì¥
        drawDecorate();
    };

    function getPos(e, canvas) {
        const r = canvas.getBoundingClientRect();
        let clientX, clientY;
        
        if (e.type.startsWith('touch')) {
            const touch = e.touches[0] || e.changedTouches[0];
            clientX = touch.clientX;
            clientY = touch.clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        return {
            x: (clientX - r.left) * (canvas.width / r.width),
            y: (clientY - r.top) * (canvas.height / r.height)
        };
    }

    function decorateStartInteract(e) {
        if(e.type === 'touchstart') {
            e.preventDefault();
            
            // ë‘ ì†ê°€ë½ í„°ì¹˜ (í•€ì¹˜ ì¤Œ)
            if (e.touches && e.touches.length === 2) {
                isPinching = true;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
                return;
            }
        }
        
        const {x, y} = getPos(e, decorateCanvas);
        
        if (mode === 'arrange') {
            let hit = false;
            for(let i = stickers.length - 1; i >= 0; i--) {
                const s = stickers[i];
                const w = s.width * s.scale, h = s.height * s.scale;
                if(x >= s.x - w/2 && x <= s.x + w/2 && y >= s.y - h/2 && y <= s.y + h/2) {
                    selectedStickerIndex = i;
                    selectedTextIndex = -1;
                    decorateIsDragging = true;
                    decorateStartX = x - s.x;
                    decorateStartY = y - s.y;
                    hit = true;
                    document.getElementById('selectedItemPanel').style.display = 'block';
                    document.getElementById('itemBorderColor').value = s.borderColor;
                    document.getElementById('itemBorderWidth').value = s.borderWidth;
                    document.getElementById('itemScale').value = s.scale * 100;
                    break;
                }
            }
            if(!hit) {
                for(let i = texts.length - 1; i >= 0; i--) {
                    const t = texts[i];
                    const hitWidth = 80 * t.scale;
                    const hitHeight = 30 * t.scale;
                    if(Math.abs(x - t.x) < hitWidth && Math.abs(y - t.y) < hitHeight) {
                        selectedTextIndex = i;
                        selectedStickerIndex = -1;
                        decorateIsDragging = true;
                        decorateStartX = x - t.x;
                        decorateStartY = y - t.y;
                        hit = true;
                        document.getElementById('selectedItemPanel').style.display = 'block';
                        document.getElementById('itemScale').value = t.scale * 100;
                        break;
                    }
                }
            }
            if(!hit) {
                document.getElementById('selectedItemPanel').style.display = 'none';
                selectedStickerIndex = -1;
                selectedTextIndex = -1;
            }
            drawDecorate();
        }
    }

    function decorateMove(e) {
        if(e.type === 'touchmove') {
            e.preventDefault();
            
            // í•€ì¹˜ ì¤Œ ì²˜ë¦¬
            if (isPinching && e.touches && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastPinchDistance > 0) {
                    const scaleDelta = distance / lastPinchDistance;
                    
                    // ì„ íƒëœ ì•„ì´í…œ í¬ê¸° ì¡°ì ˆ
                    if (selectedStickerIndex !== -1) {
                        const newScale = stickers[selectedStickerIndex].scale * scaleDelta;
                        stickers[selectedStickerIndex].scale = Math.max(0.1, Math.min(5, newScale));
                        document.getElementById('itemScale').value = stickers[selectedStickerIndex].scale * 100;
                    } else if (selectedTextIndex !== -1) {
                        const newScale = texts[selectedTextIndex].scale * scaleDelta;
                        texts[selectedTextIndex].scale = Math.max(0.1, Math.min(5, newScale));
                        document.getElementById('itemScale').value = texts[selectedTextIndex].scale * 100;
                    }
                    
                    drawDecorate();
                }
                
                lastPinchDistance = distance;
                return;
            }
        }
        
        if(!decorateIsDragging) return;
        
        const {x, y} = getPos(e, decorateCanvas);

        if(mode === 'arrange') {
            if(selectedStickerIndex !== -1) {
                stickers[selectedStickerIndex].x = x - decorateStartX;
                stickers[selectedStickerIndex].y = y - decorateStartY;
            } else if(selectedTextIndex !== -1) {
                texts[selectedTextIndex].x = x - decorateStartX;
                texts[selectedTextIndex].y = y - decorateStartY;
            }
        } else if(mode === 'move') {
            originX = x - decorateStartX;
            originY = y - decorateStartY;
        }
        drawDecorate();
    }
    
    // í„°ì¹˜ ì¢…ë£Œ ì‹œ í•€ì¹˜ ìƒíƒœ ì´ˆê¸°í™”
    function decorateEndInteract(e) {
        decorateIsDragging = false;
        if (isPinching) {
            isPinching = false;
            lastPinchDistance = 0;
            // íˆìŠ¤í† ë¦¬ ì €ì¥ (í¬ê¸° ë³€ê²½ ì™„ë£Œ)
            if (selectedStickerIndex !== -1 || selectedTextIndex !== -1) {
                saveHistory();
            }
        }
    }

    function decorateWheel(e) {
        if(mode === 'move') {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 1.1 : 0.9;
            const rect = decorateCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) * (decorateCanvas.width / rect.width);
            const mouseY = (e.clientY - rect.top) * (decorateCanvas.height / rect.height);
            
            const newScale = scale * delta;
            originX = mouseX - (mouseX - originX) * (newScale / scale);
            originY = mouseY - (mouseY - originY) * (newScale / scale);
            scale = newScale;
            drawDecorate();
        }
    }

    function downloadDecorateImage() {
        if (!decorateImg.src && stickers.length === 0 && texts.length === 0) {
            alert('ì €ì¥í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤!');
            return;
        }
        
        try {
            decorateCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `í˜¸ì†Œì¸_${getFormattedDate()}_ì¸ìŠ¤íƒ€ì‚¬ì´ì¦ˆ_1.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
        } catch (error) {
            console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
            alert('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }

    // ===== 5. ì´ë¯¸ì§€ ë¶„í•  ê¸°ëŠ¥ =====
    let splitImg = new Image();
    let splitCanvas, splitCtx;
    let splitInitialized = false;
    let splitCols = 3, splitRows = 1;
    
    // ë“œë˜ê·¸ ê´€ë ¨ ë³€ìˆ˜
    let splitOffsetX = 0, splitOffsetY = 0;
    let splitIsDragging = false;
    let splitStartX = 0, splitStartY = 0;

    function initSplit() {
        if (splitInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        splitInitialized = true;
        
        splitCanvas = document.getElementById('splitCanvas');
        splitCtx = splitCanvas.getContext('2d');
        splitCanvas.width = 500;
        splitCanvas.height = 500;
        
        document.getElementById('splitUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                splitImg.src = ev.target.result;
                splitImg.onload = function() {
                    // ì´ë¯¸ì§€ ë¡œë“œ ì‹œ ì˜¤í”„ì…‹ ì´ˆê¸°í™”
                    splitOffsetX = 0;
                    splitOffsetY = 0;
                    drawSplitPreview();
                };
            };
            reader.readAsDataURL(file);
        };
        
        // ë“œë˜ê·¸ ì´ë²¤íŠ¸
        splitCanvas.addEventListener('mousedown', splitStartDrag);
        splitCanvas.addEventListener('touchstart', splitStartDrag, {passive: false});
        splitCanvas.addEventListener('mousemove', splitDrag);
        splitCanvas.addEventListener('touchmove', splitDrag, {passive: false});
        splitCanvas.addEventListener('mouseup', splitEndDrag);
        splitCanvas.addEventListener('touchend', splitEndDrag);
        splitCanvas.addEventListener('mouseleave', splitEndDrag);
    }
    
    function splitStartDrag(e) {
        if (!splitImg.src) return;
        if (e.type === 'touchstart') e.preventDefault();
        
        const rect = splitCanvas.getBoundingClientRect();
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        
        splitIsDragging = true;
        splitStartX = clientX - rect.left - splitOffsetX;
        splitStartY = clientY - rect.top - splitOffsetY;
    }
    
    function splitDrag(e) {
        if (!splitIsDragging) return;
        if (e.type === 'touchmove') e.preventDefault();
        
        const rect = splitCanvas.getBoundingClientRect();
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        
        splitOffsetX = clientX - rect.left - splitStartX;
        splitOffsetY = clientY - rect.top - splitStartY;
        
        drawSplitPreview();
    }
    
    function splitEndDrag() {
        splitIsDragging = false;
    }

    function selectSplitMode(cols, rows, evt) {
        splitCols = cols;
        splitRows = rows;
        
        document.querySelectorAll('#splitScreen .ratio-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        const e = evt || (typeof event !== 'undefined' ? event : null);
        if (e && e.currentTarget) e.currentTarget.classList.add('selected');
        
        drawSplitPreview();
    }

    function drawSplitPreview() {
        if (!splitImg.src) return;
        
        // ê° ì…€ì˜ ì‹¤ì œ í¬ê¸° ê³„ì‚° (4:5 ë¹„ìœ¨)
        const cellWidth = splitImg.width / splitCols;
        const cellHeight = cellWidth * 1.25; // 4:5 ë¹„ìœ¨
        
        // ì „ì²´ ê·¸ë¦¬ë“œ í¬ê¸° ê³„ì‚°
        const totalWidth = splitImg.width;
        const totalHeight = cellHeight * splitRows;
        
        // ë¯¸ë¦¬ë³´ê¸° ìŠ¤ì¼€ì¼ ê³„ì‚°
        const maxSize = 500;
        const scale = Math.min(maxSize / totalWidth, maxSize / totalHeight);
        
        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        splitCanvas.width = totalWidth * scale;
        splitCanvas.height = totalHeight * scale;
        
        // ë°°ê²½ìƒ‰
        splitCtx.fillStyle = '#ffffff';
        splitCtx.fillRect(0, 0, splitCanvas.width, splitCanvas.height);
        
        // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ë“œë˜ê·¸ ì˜¤í”„ì…‹ ì ìš©)
        const imgWidth = splitImg.width * scale;
        const imgHeight = splitImg.height * scale;
        splitCtx.drawImage(
            splitImg, 
            splitOffsetX, 
            splitOffsetY, 
            imgWidth, 
            imgHeight
        );
        
        // ë¶„í• ì„  ê·¸ë¦¬ê¸°
        splitCtx.strokeStyle = '#FF5722';
        splitCtx.lineWidth = 2;
        splitCtx.setLineDash([5, 5]);
        
        const scaledCellW = cellWidth * scale;
        const scaledCellH = cellHeight * scale;
        
        // ì„¸ë¡œ ë¶„í• ì„ 
        for (let i = 1; i < splitCols; i++) {
            splitCtx.beginPath();
            splitCtx.moveTo(i * scaledCellW, 0);
            splitCtx.lineTo(i * scaledCellW, splitCanvas.height);
            splitCtx.stroke();
        }
        
        // ê°€ë¡œ ë¶„í• ì„ 
        for (let i = 1; i < splitRows; i++) {
            const y = i * scaledCellH;
            if (y < splitCanvas.height) {
                splitCtx.beginPath();
                splitCtx.moveTo(0, y);
                splitCtx.lineTo(splitCanvas.width, y);
                splitCtx.stroke();
            }
        }
        
        splitCtx.setLineDash([]);
    }

    async function splitAndDownload() {
        if (!splitImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        try {
            const zip = new JSZip();
            
            // README íŒŒì¼ ì¶”ê°€ (ë³´ì•ˆ ê²½ê³  ë°©ì§€)
            zip.file("README.txt", `í˜¸ì†Œì¸ ì—ë””í„°ë¡œ ìƒì„±ëœ ì´ë¯¸ì§€ì…ë‹ˆë‹¤.\nìƒì„±ì¼ì‹œ: ${new Date().toLocaleString('ko-KR')}\nì•ˆì „í•œ íŒŒì¼ì…ë‹ˆë‹¤.`);
            
            // ì¸ìŠ¤íƒ€ê·¸ë¨ í”¼ë“œ ë¹„ìœ¨ 4:5ë¡œ ê° ì…€ í¬ê¸° ê³„ì‚°
            const totalCols = splitCols;
            const totalRows = splitRows;
            
            // ì „ì²´ ì´ë¯¸ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê° ì…€ì˜ ë„ˆë¹„ ê³„ì‚°
            const cellWidth = splitImg.width / totalCols;
            
            // 4:5 ë¹„ìœ¨ì— ë§ì¶° ë†’ì´ ê³„ì‚° (width * 5/4)
            const cellHeight = cellWidth * 1.25;
            
            // ë¯¸ë¦¬ë³´ê¸° ìŠ¤ì¼€ì¼ ê³„ì‚°
            const maxSize = 500;
            const totalWidth = splitImg.width;
            const totalHeight = cellHeight * splitRows;
            const previewScale = Math.min(maxSize / totalWidth, maxSize / totalHeight);
            
            // ì‹¤ì œ ì˜¤í”„ì…‹ ê³„ì‚° (ë¯¸ë¦¬ë³´ê¸° ìŠ¤ì¼€ì¼ ì—­ë³´ì •)
            const actualOffsetX = splitOffsetX / previewScale;
            const actualOffsetY = splitOffsetY / previewScale;
            
            for (let r = 0; r < totalRows; r++) {
                for (let c = 0; c < totalCols; c++) {
                    const pc = document.createElement('canvas');
                    pc.width = cellWidth;
                    pc.height = cellHeight;
                    const pctx = pc.getContext('2d');
                    
                    // ì›ë³¸ ì´ë¯¸ì§€ì—ì„œ í•´ë‹¹ ìœ„ì¹˜ì˜ ì¡°ê° ì¶”ì¶œ (ì˜¤í”„ì…‹ ì ìš©)
                    const sourceX = c * cellWidth - actualOffsetX;
                    const sourceY = r * cellHeight - actualOffsetY;
                    
                    // í°ìƒ‰ ë°°ê²½ ë¨¼ì € ê·¸ë¦¬ê¸°
                    pctx.fillStyle = '#ffffff';
                    pctx.fillRect(0, 0, cellWidth, cellHeight);
                    
                    // ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                    pctx.drawImage(
                        splitImg,
                        sourceX, sourceY,
                        cellWidth, cellHeight,
                        0, 0,
                        cellWidth, cellHeight
                    );
                    
                    const dataUrl = pc.toDataURL('image/png');
                    zip.file(`í˜¸ì†Œì¸_ë¶„í• _${r+1}í–‰_${c+1}ì—´.png`, dataUrl.split(',')[1], {base64: true});
                }
            }
            
            const content = await zip.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: {
                    level: 6
                }
            });
            
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = `í˜¸ì†Œì¸_ë¶„í• ì´ë¯¸ì§€_${Date.now()}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // ë©”ëª¨ë¦¬ ì •ë¦¬
            setTimeout(() => URL.revokeObjectURL(url), 100);
            
        } catch (error) {
            console.error('ZIP ìƒì„± ì˜¤ë¥˜:', error);
            alert('ZIP íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }

    // ===== 6. í…Œë‘ë¦¬ ë‹¤ë“¬ê¸° ê¸°ëŠ¥ =====
    let cropImg = new Image();
    let cropCanvas, cropCtx;
    let cropInitialized = false;
    let croppedCanvas = null;

    function initCrop() {
        if (cropInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        cropInitialized = true;
        
        cropCanvas = document.getElementById('cropCanvas');
        cropCtx = cropCanvas.getContext('2d');
        cropCanvas.width = 500;
        cropCanvas.height = 500;
        
        document.getElementById('cropUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                cropImg.src = ev.target.result;
                cropImg.onload = function() {
                    const maxSize = 500;
                    const scale = Math.min(maxSize / cropImg.width, maxSize / cropImg.height);
                    cropCanvas.width = cropImg.width * scale;
                    cropCanvas.height = cropImg.height * scale;
                    cropCtx.drawImage(cropImg, 0, 0, cropCanvas.width, cropCanvas.height);
                    croppedCanvas = null;
                };
            };
            reader.readAsDataURL(file);
        };
        
        document.getElementById('cropAmount').oninput = function() {
            document.getElementById('cropAmountValue').textContent = this.value + 'px';
        };
    }

    function cropBorder() {
        if (!cropImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }

        const cropAmount = parseInt(document.getElementById('cropAmount').value);
        
        // ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜ ì œí•œ (ì„±ëŠ¥ ë³´í˜¸)
        const maxIterations = Math.min(cropAmount, 20);
        
        // ë¡œë”© í‘œì‹œ
        const originalText = document.querySelector('.btn.primary[onclick="cropBorder()"]').textContent;
        document.querySelector('.btn.primary[onclick="cropBorder()"]').textContent = 'â³ ì²˜ë¦¬ ì¤‘...';
        document.querySelector('.btn.primary[onclick="cropBorder()"]').disabled = true;
        
        // ë¬´ê±°ìš´ ì‘ì—…ì€ setTimeoutìœ¼ë¡œ ë¹„ë™ê¸° ì²˜ë¦¬
        setTimeout(() => {
            try {
                // ì„±ëŠ¥ ê°œì„ : í° ì´ë¯¸ì§€ëŠ” ë¦¬ì‚¬ì´ì§•í•´ì„œ ì²˜ë¦¬
                const MAX_PROCESS_SIZE = 1500; // ì²˜ë¦¬ ìµœëŒ€ í¬ê¸°
                let processWidth = cropImg.width;
                let processHeight = cropImg.height;
                let scale = 1;
                
                if (cropImg.width > MAX_PROCESS_SIZE || cropImg.height > MAX_PROCESS_SIZE) {
                    scale = MAX_PROCESS_SIZE / Math.max(cropImg.width, cropImg.height);
                    processWidth = Math.floor(cropImg.width * scale);
                    processHeight = Math.floor(cropImg.height * scale);
                }
                
                // ì›ë³¸ í¬ê¸° ì„ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = processWidth;
                tempCanvas.height = processHeight;
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                tempCtx.drawImage(cropImg, 0, 0, processWidth, processHeight);
                
                // ì´ë¯¸ì§€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                let imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                let data = imageData.data;
                
                // ì—¬ëŸ¬ ë²ˆ ì¹¨ì‹(erosion) ë°˜ë³µí•´ì„œ í…Œë‘ë¦¬ ê¹ê¸° (ìµœëŒ€ 20íšŒë¡œ ì œí•œ)
                const adjustedIterations = Math.ceil(maxIterations * scale); // ë¦¬ì‚¬ì´ì§• ë¹„ìœ¨ì— ë§ì¶° ì¡°ì •
                
                for (let iter = 0; iter < adjustedIterations; iter++) {
                    // ìƒˆë¡œìš´ ì´ë¯¸ì§€ ë°ì´í„° ìƒì„±
                    const newImageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
                    const newData = newImageData.data;
                    
                    // ê° í”½ì…€ ì²˜ë¦¬
                    for (let y = 0; y < tempCanvas.height; y++) {
                        for (let x = 0; x < tempCanvas.width; x++) {
                            const idx = (y * tempCanvas.width + x) * 4;
                            const alpha = data[idx + 3];
                            
                            // ì´ë¯¸ íˆ¬ëª…í•œ í”½ì…€ì€ ê·¸ëŒ€ë¡œ
                            if (alpha < 10) {
                                newData[idx + 3] = 0;
                                continue;
                            }
                            
                            // ì£¼ë³€ 4ë°©í–¥ë§Œ ì²´í¬ (ì„±ëŠ¥ ê°œì„ : 8ë°©í–¥ â†’ 4ë°©í–¥)
                            let hasTransparent = false;
                            const directions = [
                                [0, -1], [0, 1], [-1, 0], [1, 0] // ìƒí•˜ì¢Œìš°ë§Œ
                            ];
                            
                            for (const [dx, dy] of directions) {
                                const checkX = x + dx;
                                const checkY = y + dy;
                                
                                // ë²”ìœ„ ì²´í¬
                                if (checkX < 0 || checkX >= tempCanvas.width || 
                                    checkY < 0 || checkY >= tempCanvas.height) {
                                    hasTransparent = true;
                                    break;
                                }
                                
                                const checkIdx = (checkY * tempCanvas.width + checkX) * 4;
                                const checkAlpha = data[checkIdx + 3];
                                
                                // ì£¼ë³€ì— íˆ¬ëª… í”½ì…€ì´ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´
                                if (checkAlpha < 10) {
                                    hasTransparent = true;
                                    break;
                                }
                            }
                            
                            // ì£¼ë³€ì— íˆ¬ëª… í”½ì…€ì´ ì—†ìœ¼ë©´ ì‚´ë¦¬ê¸°
                            if (!hasTransparent) {
                                newData[idx] = data[idx];
                                newData[idx + 1] = data[idx + 1];
                                newData[idx + 2] = data[idx + 2];
                                newData[idx + 3] = data[idx + 3];
                            } else {
                                // í…Œë‘ë¦¬ í”½ì…€ì€ íˆ¬ëª…í•˜ê²Œ
                                newData[idx + 3] = 0;
                            }
                        }
                    }
                    
                    // ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ ë°ì´í„° ì—…ë°ì´íŠ¸
                    imageData = newImageData;
                    data = newData;
                }
                
                // ìµœì¢… ì´ë¯¸ì§€ ì ìš©
                tempCtx.putImageData(imageData, 0, 0);
                
                // ì›ë³¸ í¬ê¸°ë¡œ ë‹¤ì‹œ í™•ëŒ€ (ë¦¬ì‚¬ì´ì§•í–ˆë˜ ê²½ìš°)
                if (scale < 1) {
                    const finalCanvas = document.createElement('canvas');
                    finalCanvas.width = cropImg.width;
                    finalCanvas.height = cropImg.height;
                    const finalCtx = finalCanvas.getContext('2d');
                    finalCtx.drawImage(tempCanvas, 0, 0, cropImg.width, cropImg.height);
                    
                    // íˆ¬ëª… ì˜ì—­ ì œê±°
                    const trimmed = trimTransparent(finalCanvas);
                    croppedCanvas = trimmed.canvas;
                } else {
                    // íˆ¬ëª… ì˜ì—­ ì œê±°
                    const trimmed = trimTransparent(tempCanvas);
                    croppedCanvas = trimmed.canvas;
                }
                
                // ë¯¸ë¦¬ë³´ê¸°
                const maxSize = 500;
                const previewScale = Math.min(maxSize / croppedCanvas.width, maxSize / croppedCanvas.height);
                cropCanvas.width = croppedCanvas.width * previewScale;
                cropCanvas.height = croppedCanvas.height * previewScale;
                
                // ì²´í¬ë¬´ëŠ¬ ë°°ê²½
                cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
                const checkSize = 10;
                for (let y = 0; y < cropCanvas.height; y += checkSize) {
                    for (let x = 0; x < cropCanvas.width; x += checkSize) {
                        cropCtx.fillStyle = ((x / checkSize + y / checkSize) % 2 === 0) ? '#ffffff' : '#e0e0e0';
                        cropCtx.fillRect(x, y, checkSize, checkSize);
                    }
                }
                
                cropCtx.drawImage(croppedCanvas, 0, 0, cropCanvas.width, cropCanvas.height);
                
                alert(`âœ… í…Œë‘ë¦¬ ë‹¤ë“¬ê¸° ì™„ë£Œ!\n\në‹¤ë“¬ì€ ë‘ê»˜: ${cropAmount}px\nì›ë³¸ í¬ê¸°: ${cropImg.width} Ã— ${cropImg.height}\nê²°ê³¼ í¬ê¸°: ${croppedCanvas.width} Ã— ${croppedCanvas.height}`);
                
            } catch (error) {
                console.error('í…Œë‘ë¦¬ ë‹¤ë“¬ê¸° ì˜¤ë¥˜:', error);
                alert('ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. 5MB ì´í•˜ë¡œ ì˜¬ë ¤ì£¼ì„¸ìš”!');
            } finally {
                // ë²„íŠ¼ ë³µêµ¬
                document.querySelector('.btn.primary[onclick="cropBorder()"]').textContent = originalText;
                document.querySelector('.btn.primary[onclick="cropBorder()"]').disabled = false;
            }
        }, 100);
    }
    
    // íˆ¬ëª… ì˜ì—­ ìë™ ì œê±° í•¨ìˆ˜
    function trimTransparent(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const alpha = data[(y * canvas.width + x) * 4 + 3];
                if (alpha > 10) {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                }
            }
        }
        
        const width = maxX - minX + 1;
        const height = maxY - minY + 1;
        
        const newCanvas = document.createElement('canvas');
        newCanvas.width = width;
        newCanvas.height = height;
        const newCtx = newCanvas.getContext('2d');
        newCtx.drawImage(canvas, minX, minY, width, height, 0, 0, width, height);
        
        return { canvas: newCanvas, x: minX, y: minY };
    }

    function downloadCroppedImage() {
        if (!cropImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        if (!croppedCanvas) {
            alert('ë¨¼ì € í…Œë‘ë¦¬ ì œê±°ë¥¼ ì‹¤í–‰í•´ì£¼ì„¸ìš”!');
            return;
        }
        
        try {
            croppedCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `í˜¸ì†Œì¸_${new Date().toISOString().slice(0,10)}_í…Œë‘ë¦¬ë‹¤ë“¬ê¸°_1.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png');
        } catch (error) {
            console.error('ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜:', error);
            alert('ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }
    
    // ===== ì´ë¯¸ì§€ ê³µìœ  ê¸°ëŠ¥ =====
    async function shareImage(canvas, filename = 'í¸ì§‘ëœ_ì´ë¯¸ì§€.png') {
        try {
            // Canvasë¥¼ Blobìœ¼ë¡œ ë³€í™˜
            const blob = await new Promise(resolve => {
                canvas.toBlob(resolve, 'image/png');
            });
            
            // Web Share API ì§€ì› í™•ì¸
            if (navigator.share && navigator.canShare) {
                const file = new File([blob], filename, { type: 'image/png' });
                const shareData = {
                    files: [file],
                    title: 'í¸ì§‘ëœ ì´ë¯¸ì§€',
                    text: 'í˜¸ì†Œì¸ ì—ë””í„°ë¡œ í¸ì§‘í•œ ì´ë¯¸ì§€'
                };
                
                if (navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                    return;
                }
            }
            
            // Web Share API ë¯¸ì§€ì›ì‹œ ë‹¤ìš´ë¡œë“œ
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('ê³µìœ  ê¸°ëŠ¥ì´ ì§€ì›ë˜ì§€ ì•Šì•„ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.\në‹¤ìš´ë¡œë“œëœ ì´ë¯¸ì§€ë¥¼ ì§ì ‘ ê³µìœ í•´ì£¼ì„¸ìš”!');
            
        } catch (error) {
            console.error('ê³µìœ  ì˜¤ë¥˜:', error);
            alert('ê³µìœ  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    
    // ê° í™”ë©´ë³„ ê³µìœ  í•¨ìˆ˜ë“¤
    function shareRatioImage() {
        if (!ratioImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // ë‹¤ìš´ë¡œë“œìš© ìº”ë²„ìŠ¤ ìƒì„± (downloadRatioImageì™€ ë™ì¼í•œ ë¡œì§)
        let downloadWidth, downloadHeight;
        
        if (selectedRatioW === 'youtube') {
            downloadWidth = 2560;
            downloadHeight = 1440;
        } else if (selectedRatioW === 'twitter') {
            downloadWidth = 1500;
            downloadHeight = 500;
        } else {
            const maxDimension = 2048;
            if (selectedRatioW >= selectedRatioH) {
                downloadWidth = maxDimension;
                downloadHeight = maxDimension * (selectedRatioH / selectedRatioW);
            } else {
                downloadHeight = maxDimension;
                downloadWidth = maxDimension * (selectedRatioW / selectedRatioH);
            }
        }
        
        const downloadCanvas = document.createElement('canvas');
        downloadCanvas.width = downloadWidth;
        downloadCanvas.height = downloadHeight;
        const downloadCtx = downloadCanvas.getContext('2d');
        
        downloadCtx.fillStyle = ratioBgColor;
        downloadCtx.fillRect(0, 0, downloadWidth, downloadHeight);
        
        const scale = Math.min(
            downloadWidth / ratioImg.width,
            downloadHeight / ratioImg.height
        );
        
        const scaledW = ratioImg.width * scale;
        const scaledH = ratioImg.height * scale;
        const x = (downloadWidth - scaledW) / 2;
        const y = (downloadHeight - scaledH) / 2;
        
        downloadCtx.drawImage(ratioImg, x, y, scaledW, scaledH);
        
        shareImage(downloadCanvas, 'ë¹„ìœ¨ë³€ê²½_ì´ë¯¸ì§€.png');
    }
    
    function shareMergedImage() {
        if (!mergedCanvas) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ í•©ì³ì£¼ì„¸ìš”!');
            return;
        }
        shareImage(mergedCanvas, 'í•©ì¹œ_ì´ë¯¸ì§€.png');
    }
    
    function shareCollageImage() {
        if (!collageImg1.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        shareImage(collageCanvas, 'ì½œë¼ì£¼_ì´ë¯¸ì§€.png');
    }
    
    function shareDecorateImage() {
        if (!decorateImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        shareImage(decorateCanvas, 'ê¾¸ë¯¼_ì´ë¯¸ì§€.png');
    }
    
    function shareCroppedImage() {
        if (!croppedCanvas) {
            alert('ë¨¼ì € í…Œë‘ë¦¬ ì œê±°ë¥¼ ì‹¤í–‰í•´ì£¼ì„¸ìš”!');
            return;
        }
        shareImage(croppedCanvas, 'í…Œë‘ë¦¬ì œê±°_ì´ë¯¸ì§€.png');
    }
    
    // ===== PWA Service Worker ë“±ë¡ =====
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('/service-worker.js')
                .then(function(registration) {
                    console.log('ServiceWorker registration successful');
                })
                .catch(function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
        });
    }

    
    // ===== ê³µìœ  ê¸°ëŠ¥ =====
    function shareToInstagram() {
        alert('ğŸ’¡ TIP: ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•œ í›„\nì¸ìŠ¤íƒ€ê·¸ë¨ ì•±ì—ì„œ ì§ì ‘ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
    }
    
    function shareToKakao() {
        alert('ğŸ’¡ TIP: ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•œ í›„\nì¹´ì¹´ì˜¤í†¡ì—ì„œ ì§ì ‘ ê³µìœ í•´ì£¼ì„¸ìš”!');
    }
    
    function shareToTiktok() {
        alert('ğŸ’¡ TIP: ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•œ í›„\ní‹±í†¡ ì•±ì—ì„œ ì§ì ‘ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
    }
    
    // ===== ë‚ ì§œ í¬ë§· í•¨ìˆ˜ =====
    function getFormattedDate() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hour = String(now.getHours()).padStart(2, '0');
        const minute = String(now.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}_${hour}-${minute}`;
    }
    
    // ===== ë¡œë”© ì˜¤ë²„ë ˆì´ =====
    function showLoading(show = true, message = 'ì²˜ë¦¬ ì¤‘...', progress = 0) {
        let overlay = document.getElementById('loadingOverlay');
        if (!overlay && show) {
            overlay = document.createElement('div');
            overlay.id = 'loadingOverlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 9999; display: flex; align-items: center; justify-content: center;';
            overlay.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 20px; text-align: center; min-width: 280px;">
                    <div style="width: 60px; height: 60px; border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                    <div style="font-size: 16px; font-weight: 700; color: var(--primary); margin-bottom: 10px;">${message}</div>
                    <div id="loadingProgress" style="font-size: 24px; font-weight: 900; color: var(--accent);">${progress}%</div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // CSS ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
            if (!document.getElementById('spinStyle')) {
                const style = document.createElement('style');
                style.id = 'spinStyle';
                style.textContent = '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
                document.head.appendChild(style);
            }
        }
        if (overlay) {
            overlay.style.display = show ? 'flex' : 'none';
            if (show) {
                const progressEl = overlay.querySelector('#loadingProgress');
                if (progressEl) progressEl.textContent = progress + '%';
            }
        }
    }
    
    function updateProgress(progress) {
        const progressEl = document.getElementById('loadingProgress');
        if (progressEl) {
            progressEl.textContent = Math.round(progress) + '%';
        }
    }

    // ===== 7. ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥ =====
    let previewImg = new Image();
    let previewProfileImg = new Image(); // í”„ë¡œí•„ ì‚¬ì§„ ì¶”ê°€
    let previewCanvas, previewCtx;
    let previewInitialized = false;
    let previewMode = 'profile'; // 'profile', 'youtube', 'twitter', 'facebook'
    let previewOffsetX = 0, previewOffsetY = 0;
    let previewScale = 1;
    let previewIsDragging = false;
    let previewStartX = 0, previewStartY = 0;
    let previewInitialDistance = 0;
    let previewInitialScale = 1;

    function initPreview() {
        if (previewInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        previewInitialized = true;
        
        previewCanvas = document.getElementById('previewCanvas');
        previewCtx = previewCanvas.getContext('2d');
        previewCanvas.width = 500;
        previewCanvas.height = 500;
        
        // ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ
        document.getElementById('previewUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                previewImg.src = ev.target.result;
                previewImg.onload = function() {
                    previewOffsetX = 0;
                    previewOffsetY = 0;
                    previewScale = 1;
                    drawPreview();
                };
            };
            reader.readAsDataURL(file);
        };
        
        // í”„ë¡œí•„ ì‚¬ì§„ ì—…ë¡œë“œ
        document.getElementById('previewProfileUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                previewProfileImg.src = ev.target.result;
                previewProfileImg.onload = function() {
                    drawPreview();
                };
            };
            reader.readAsDataURL(file);
        };
        
        // ë“œë˜ê·¸ ì´ë²¤íŠ¸
        previewCanvas.addEventListener('mousedown', previewStartDrag);
        previewCanvas.addEventListener('touchstart', previewStartDrag, {passive: false});
        previewCanvas.addEventListener('mousemove', previewDrag);
        previewCanvas.addEventListener('touchmove', previewDrag, {passive: false});
        previewCanvas.addEventListener('mouseup', previewEndDrag);
        previewCanvas.addEventListener('touchend', previewEndDrag);
        previewCanvas.addEventListener('mouseleave', previewEndDrag);
        
        // ë§ˆìš°ìŠ¤ íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ
        previewCanvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            if (!previewImg.src) return;
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            previewScale = Math.max(0.1, Math.min(5, previewScale * delta));
            drawPreview();
        }, {passive: false});
    }
    
    function previewStartDrag(e) {
        if (!previewImg.src) return;
        if (e.type === 'touchstart') e.preventDefault();
        
        // ë‘ ì†ê°€ë½ í„°ì¹˜ - í•€ì¹˜ ì¤Œ
        if (e.type === 'touchstart' && e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            previewInitialDistance = Math.sqrt(dx * dx + dy * dy);
            previewInitialScale = previewScale;
            previewIsDragging = false;
            return;
        }
        
        const rect = previewCanvas.getBoundingClientRect();
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        
        previewIsDragging = true;
        previewStartX = clientX - rect.left - previewOffsetX;
        previewStartY = clientY - rect.top - previewOffsetY;
    }
    
    function previewDrag(e) {
        if (e.type === 'touchmove') e.preventDefault();
        
        // ë‘ ì†ê°€ë½ í„°ì¹˜ - í•€ì¹˜ ì¤Œ
        if (e.type === 'touchmove' && e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            previewScale = Math.max(0.1, Math.min(5, previewInitialScale * (distance / previewInitialDistance)));
            drawPreview();
            return;
        }
        
        if (!previewIsDragging) return;
        
        const rect = previewCanvas.getBoundingClientRect();
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
        
        previewOffsetX = clientX - rect.left - previewStartX;
        previewOffsetY = clientY - rect.top - previewStartY;
        
        drawPreview();
    }
    
    function previewEndDrag() {
        previewIsDragging = false;
    }
    
    function alignPreviewPosition(align) {
        if (!previewImg.src) return;
        
        previewScale = 1;
        previewOffsetY = 0;
        
        // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ì— ë§ì¶°ì§€ëŠ” ì‹¤ì œ í¬ê¸° ê³„ì‚°
        const scale = Math.min(
            previewCanvas.width / previewImg.width,
            previewCanvas.height / previewImg.height
        );
        const scaledW = previewImg.width * scale;
        
        if (align === 'left') {
            // ì™¼ìª½ ì •ë ¬: ì´ë¯¸ì§€ ì™¼ìª½ ëì´ ìº”ë²„ìŠ¤ ì™¼ìª½ì— ë¶™ë„ë¡
            previewOffsetX = -scaledW / 2;
        } else if (align === 'center') {
            // ê°€ìš´ë° ì •ë ¬: ê¸°ë³¸ê°’
            previewOffsetX = 0;
        } else if (align === 'right') {
            // ìš°ì¸¡ ì •ë ¬: ì´ë¯¸ì§€ ì˜¤ë¥¸ìª½ ëì´ ìº”ë²„ìŠ¤ ì˜¤ë¥¸ìª½ì— ë¶™ë„ë¡
            previewOffsetX = (previewCanvas.width - scaledW) / 2;
        }
        
        drawPreview();
    }
    
    // í˜¸í™˜ì„±ì„ ìœ„í•œ ê¸°ì¡´ í•¨ìˆ˜ ìœ ì§€
    function resetPreviewPosition() {
        alignPreviewPosition('center');
    }
    
    function selectPreviewMode(mode, evt) {
        previewMode = mode;
        document.querySelectorAll('#previewScreen .ratio-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        const e = evt || (typeof event !== 'undefined' ? event : null);
        if (e && e.currentTarget) e.currentTarget.classList.add('selected');
        
        if (previewImg.src) {
            drawPreview();
        }
    }
    
    function drawPreview() {
        if (!previewImg.src) return;
        
        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        if (previewMode === 'profile') {
            previewCanvas.width = 500;
            previewCanvas.height = 500;
        } else if (previewMode === 'youtube') {
            previewCanvas.width = 500;
            previewCanvas.height = 500 * (1440 / 2560);
        } else if (previewMode === 'twitter') {
            previewCanvas.width = 500;
            previewCanvas.height = 500 * (500 / 1500);
        } else if (previewMode === 'facebook') {
            previewCanvas.width = 500;
            previewCanvas.height = 500 * (312 / 820);
        }
        
        // ë°°ê²½ ê·¸ë¦¬ê¸°
        previewCtx.fillStyle = '#e0e0e0';
        previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        const scale = Math.min(previewCanvas.width / previewImg.width, previewCanvas.height / previewImg.height) * previewScale;
        const scaledW = previewImg.width * scale;
        const scaledH = previewImg.height * scale;
        const x = (previewCanvas.width - scaledW) / 2 + previewOffsetX;
        const y = (previewCanvas.height - scaledH) / 2 + previewOffsetY;
        
        previewCtx.drawImage(previewImg, x, y, scaledW, scaledH);
        
        // ëª¨ë“œë³„ ì˜¤ë²„ë ˆì´ ê·¸ë¦¬ê¸°
        if (previewMode === 'profile') {
            drawProfilePreview();
        } else if (previewMode === 'youtube') {
            drawYoutubePreview();
        } else if (previewMode === 'twitter') {
            drawTwitterPreview();
        } else if (previewMode === 'facebook') {
            drawFacebookPreview();
        }
    }
    
    function drawProfilePreview() {
        // ì›í˜• í´ë¦¬í•‘ ë§ˆìŠ¤í¬
        previewCtx.save();
        previewCtx.globalCompositeOperation = 'destination-in';
        previewCtx.beginPath();
        previewCtx.arc(previewCanvas.width / 2, previewCanvas.height / 2, previewCanvas.width / 2, 0, Math.PI * 2);
        previewCtx.fill();
        previewCtx.restore();
        
        // ì›í˜• í…Œë‘ë¦¬
        previewCtx.strokeStyle = '#11593F';
        previewCtx.lineWidth = 4;
        previewCtx.beginPath();
        previewCtx.arc(previewCanvas.width / 2, previewCanvas.height / 2, previewCanvas.width / 2 - 2, 0, Math.PI * 2);
        previewCtx.stroke();
    }
    
    function drawYoutubePreview() {
        // TV (2560 x 1440) - ì „ì²´ ì˜ì—­ (ì´ë¯¸ ê·¸ë ¤ì§)
        previewCtx.strokeStyle = '#FF0000';
        previewCtx.lineWidth = 2;
        previewCtx.setLineDash([]);
        previewCtx.strokeRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        previewCtx.fillStyle = '#FF0000';
        previewCtx.font = 'bold 10px Arial';
        previewCtx.fillText('TV', 5, 12);
        
        // ë°ìŠ¤í¬í†± (2560 x 423 ì¤‘ì•™)
        const pcHeight = (423 / 1440) * previewCanvas.height;
        const pcY = (previewCanvas.height - pcHeight) / 2;
        previewCtx.strokeStyle = '#FFA500';
        previewCtx.lineWidth = 2;
        previewCtx.setLineDash([5, 3]);
        previewCtx.strokeRect(0, pcY, previewCanvas.width, pcHeight);
        previewCtx.fillStyle = '#FFA500';
        previewCtx.fillText('PC', 5, pcY + 12);
        
        // íƒœë¸”ë¦¿ (1855 x 423 ì¤‘ì•™)
        const tabletWidth = (1855 / 2560) * previewCanvas.width;
        const tabletX = (previewCanvas.width - tabletWidth) / 2;
        previewCtx.strokeStyle = '#FFD700';
        previewCtx.lineWidth = 2;
        previewCtx.setLineDash([3, 2]);
        previewCtx.strokeRect(tabletX, pcY, tabletWidth, pcHeight);
        previewCtx.fillStyle = '#FFD700';
        previewCtx.fillText('TABLET', tabletX + 5, pcY + 12);
        
        // ëª¨ë°”ì¼ (1546 x 423 ì¤‘ì•™) - ìµœì†Œ ì•ˆì „ ì˜ì—­
        const phoneWidth = (1546 / 2560) * previewCanvas.width;
        const phoneX = (previewCanvas.width - phoneWidth) / 2;
        previewCtx.strokeStyle = '#00FF00';
        previewCtx.lineWidth = 3;
        previewCtx.setLineDash([]);
        previewCtx.strokeRect(phoneX, pcY, phoneWidth, pcHeight);
        previewCtx.fillStyle = '#00FF00';
        previewCtx.font = 'bold 11px Arial';
        previewCtx.fillText('PHONE (Safe Area)', phoneX + 5, pcY + 14);
        
        previewCtx.setLineDash([]);
    }
    
    function drawTwitterPreview() {
        // í”„ë¡œí•„ ì‚¬ì§„ ìœ„ì¹˜ (ì™¼ìª½ ì•„ë˜)
        const profileSize = (200 / 1500) * previewCanvas.width;
        const profileX = (16 / 1500) * previewCanvas.width;
        const profileY = previewCanvas.height - profileSize / 2;
        
        // í”„ë¡œí•„ ì‚¬ì§„ì´ ìˆìœ¼ë©´ ì‹¤ì œ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        if (previewProfileImg.src) {
            previewCtx.save();
            
            // ì›í˜• í´ë¦¬í•‘
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.clip();
            
            // í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ì› ì•ˆì— ë§ì¶° ê·¸ë¦¬ê¸°
            const scale = Math.max(profileSize / previewProfileImg.width, profileSize / previewProfileImg.height);
            const imgW = previewProfileImg.width * scale;
            const imgH = previewProfileImg.height * scale;
            const imgX = profileX + (profileSize - imgW) / 2;
            const imgY = profileY - profileSize / 2 + (profileSize - imgH) / 2;
            
            previewCtx.drawImage(previewProfileImg, imgX, imgY, imgW, imgH);
            previewCtx.restore();
            
            // ì›í˜• í…Œë‘ë¦¬ (í°ìƒ‰ ë°°ê²½ + íŒŒë€ìƒ‰ í…Œë‘ë¦¬)
            previewCtx.strokeStyle = '#FFFFFF';
            previewCtx.lineWidth = 5;
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.stroke();
            
            previewCtx.strokeStyle = '#1DA1F2';
            previewCtx.lineWidth = 2;
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.stroke();
        } else {
            // í”„ë¡œí•„ ì‚¬ì§„ì´ ì—†ìœ¼ë©´ ê°€ì´ë“œë§Œ í‘œì‹œ
            // í”„ë¡œí•„ ì‚¬ì§„ ë°˜íˆ¬ëª… ë°°ê²½
            previewCtx.fillStyle = 'rgba(29, 161, 242, 0.2)';
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.fill();
            
            // í”„ë¡œí•„ ì‚¬ì§„ ì›í˜• í…Œë‘ë¦¬
            previewCtx.strokeStyle = '#1DA1F2';
            previewCtx.lineWidth = 3;
            previewCtx.setLineDash([5, 3]);
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.stroke();
            previewCtx.setLineDash([]);
            
            // ì•ˆë‚´ í…ìŠ¤íŠ¸
            previewCtx.fillStyle = '#1DA1F2';
            previewCtx.font = 'bold 10px Arial';
            previewCtx.fillText('Profile Photo', profileX + profileSize + 10, profileY);
        }
    }
    
    function drawFacebookPreview() {
        // í˜ì´ìŠ¤ë¶ ì»¤ë²„ (820 x 312)
        // í”„ë¡œí•„ ì‚¬ì§„ ìœ„ì¹˜ (ì™¼ìª½ ì•„ë˜)
        const profileSize = (168 / 820) * previewCanvas.width;
        const profileX = (24 / 820) * previewCanvas.width;
        const profileY = previewCanvas.height - profileSize / 4;
        
        // í”„ë¡œí•„ ì‚¬ì§„ì´ ìˆìœ¼ë©´ ì‹¤ì œ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        if (previewProfileImg.src) {
            previewCtx.save();
            
            // ì›í˜• í´ë¦¬í•‘
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.clip();
            
            // í”„ë¡œí•„ ì´ë¯¸ì§€ë¥¼ ì› ì•ˆì— ë§ì¶° ê·¸ë¦¬ê¸°
            const scale = Math.max(profileSize / previewProfileImg.width, profileSize / previewProfileImg.height);
            const imgW = previewProfileImg.width * scale;
            const imgH = previewProfileImg.height * scale;
            const imgX = profileX + (profileSize - imgW) / 2;
            const imgY = profileY - profileSize / 2 + (profileSize - imgH) / 2;
            
            previewCtx.drawImage(previewProfileImg, imgX, imgY, imgW, imgH);
            previewCtx.restore();
            
            // ì›í˜• í…Œë‘ë¦¬ (í°ìƒ‰ ë°°ê²½ + íŒŒë€ìƒ‰ í…Œë‘ë¦¬)
            previewCtx.strokeStyle = '#FFFFFF';
            previewCtx.lineWidth = 5;
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.stroke();
            
            previewCtx.strokeStyle = '#1877F2';
            previewCtx.lineWidth = 2;
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.stroke();
        } else {
            // í”„ë¡œí•„ ì‚¬ì§„ì´ ì—†ìœ¼ë©´ ê°€ì´ë“œë§Œ í‘œì‹œ
            // í”„ë¡œí•„ ì‚¬ì§„ ë°˜íˆ¬ëª… ë°°ê²½
            previewCtx.fillStyle = 'rgba(24, 119, 242, 0.2)';
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.fill();
            
            // í”„ë¡œí•„ ì‚¬ì§„ ì›í˜• í…Œë‘ë¦¬
            previewCtx.strokeStyle = '#1877F2';
            previewCtx.lineWidth = 3;
            previewCtx.setLineDash([5, 3]);
            previewCtx.beginPath();
            previewCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
            previewCtx.stroke();
            previewCtx.setLineDash([]);
            
            // ì•ˆë‚´ í…ìŠ¤íŠ¸
            previewCtx.fillStyle = '#1877F2';
            previewCtx.font = 'bold 9px Arial';
            previewCtx.fillText('Profile Photo', profileX, profileY - profileSize / 2 - 8);
        }
    }
    
    function downloadPreviewImage() {
        if (!previewImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // ë‹¤ìš´ë¡œë“œìš© ê³ í•´ìƒë„ ìº”ë²„ìŠ¤
        let downloadW, downloadH;
        if (previewMode === 'profile') {
            downloadW = downloadH = 1080;
        } else if (previewMode === 'youtube') {
            downloadW = 2560;
            downloadH = 1440;
        } else if (previewMode === 'twitter') {
            downloadW = 1500;
            downloadH = 500;
        } else if (previewMode === 'facebook') {
            downloadW = 820;
            downloadH = 312;
        }
        
        const downloadCanvas = document.createElement('canvas');
        downloadCanvas.width = downloadW;
        downloadCanvas.height = downloadH;
        const downloadCtx = downloadCanvas.getContext('2d');
        
        // ë°°ê²½ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        const scale = Math.min(downloadW / previewImg.width, downloadH / previewImg.height);
        const scaledW = previewImg.width * scale;
        const scaledH = previewImg.height * scale;
        const x = (downloadW - scaledW) / 2;
        const y = (downloadH - scaledH) / 2;
        
        downloadCtx.drawImage(previewImg, x, y, scaledW, scaledH);
        
        // í”„ë¡œí•„ ì‚¬ì§„ì´ ìˆê³ , íŠ¸ìœ„í„°/í˜ì´ìŠ¤ë¶ ëª¨ë“œë©´ í”„ë¡œí•„ ì‚¬ì§„ë„ ê·¸ë¦¬ê¸°
        if (previewProfileImg.src && (previewMode === 'twitter' || previewMode === 'facebook')) {
            if (previewMode === 'twitter') {
                const profileSize = 200;
                const profileX = 16;
                const profileY = downloadH - profileSize / 2;
                
                downloadCtx.save();
                downloadCtx.beginPath();
                downloadCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
                downloadCtx.clip();
                
                const profScale = Math.max(profileSize / previewProfileImg.width, profileSize / previewProfileImg.height);
                const profW = previewProfileImg.width * profScale;
                const profH = previewProfileImg.height * profScale;
                const profX = profileX + (profileSize - profW) / 2;
                const profY = profileY - profileSize / 2 + (profileSize - profH) / 2;
                
                downloadCtx.drawImage(previewProfileImg, profX, profY, profW, profH);
                downloadCtx.restore();
                
                // í…Œë‘ë¦¬
                downloadCtx.strokeStyle = '#FFFFFF';
                downloadCtx.lineWidth = 8;
                downloadCtx.beginPath();
                downloadCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
                downloadCtx.stroke();
                
                downloadCtx.strokeStyle = '#1DA1F2';
                downloadCtx.lineWidth = 4;
                downloadCtx.beginPath();
                downloadCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
                downloadCtx.stroke();
            } else if (previewMode === 'facebook') {
                const profileSize = 168;
                const profileX = 24;
                const profileY = downloadH - profileSize / 4;
                
                downloadCtx.save();
                downloadCtx.beginPath();
                downloadCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
                downloadCtx.clip();
                
                const profScale = Math.max(profileSize / previewProfileImg.width, profileSize / previewProfileImg.height);
                const profW = previewProfileImg.width * profScale;
                const profH = previewProfileImg.height * profScale;
                const profX = profileX + (profileSize - profW) / 2;
                const profY = profileY - profileSize / 2 + (profileSize - profH) / 2;
                
                downloadCtx.drawImage(previewProfileImg, profX, profY, profW, profH);
                downloadCtx.restore();
                
                // í…Œë‘ë¦¬
                downloadCtx.strokeStyle = '#FFFFFF';
                downloadCtx.lineWidth = 8;
                downloadCtx.beginPath();
                downloadCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
                downloadCtx.stroke();
                
                downloadCtx.strokeStyle = '#1877F2';
                downloadCtx.lineWidth = 4;
                downloadCtx.beginPath();
                downloadCtx.arc(profileX + profileSize / 2, profileY, profileSize / 2, 0, Math.PI * 2);
                downloadCtx.stroke();
            }
        }
        
        downloadCanvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `í˜¸ì†Œì¸_ë¯¸ë¦¬ë³´ê¸°_${previewMode}_${getFormattedDate()}.png`;
            a.click();
            URL.revokeObjectURL(url);
        });
    }
    
    function sharePreviewImage() {
        if (!previewImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // ê³µìœ ìš©ìœ¼ë¡œ í˜„ì¬ ìº”ë²„ìŠ¤ ì‚¬ìš©
        shareImage(previewCanvas, `ë¯¸ë¦¬ë³´ê¸°_${previewMode}.png`);
    }

    // ===== 8. ì´ë¯¸ì§€ ìë¥´ê¸° ê¸°ëŠ¥ =====
    let trimCanvas, trimCtx;
    let trimInitialized = false;
    let trimImg = new Image();
    let trimArea = { x: 0, y: 0, width: 0, height: 0 };
    let trimDragging = false;
    let trimDragHandle = null; // 'move', 'nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'
    let trimDragStartX, trimDragStartY;
    let trimmedResult = null;

    function initTrim() {
        if (trimInitialized) return; // ì´ë¯¸ ì´ˆê¸°í™”ëìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        trimInitialized = true;
        
        trimCanvas = document.getElementById('trimCanvas');
        trimCtx = trimCanvas.getContext('2d');
        trimCanvas.width = 500;
        trimCanvas.height = 500;
        
        document.getElementById('trimUpload').onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(ev) {
                trimImg.src = ev.target.result;
                trimImg.onload = function() {
                    // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                    const maxSize = 600;
                    if (trimImg.width > trimImg.height) {
                        trimCanvas.width = maxSize;
                        trimCanvas.height = maxSize * (trimImg.height / trimImg.width);
                    } else {
                        trimCanvas.height = maxSize;
                        trimCanvas.width = maxSize * (trimImg.width / trimImg.height);
                    }
                    
                    // ì´ˆê¸° ìë¥´ê¸° ì˜ì—­ ì„¤ì • (ì „ì²´)
                    trimArea = {
                        x: 0,
                        y: 0,
                        width: trimCanvas.width,
                        height: trimCanvas.height
                    };
                    
                    trimmedResult = null;
                    drawTrimCanvas();
                };
            };
            reader.readAsDataURL(file);
        };
        
        // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        trimCanvas.addEventListener('mousedown', startTrimDrag);
        trimCanvas.addEventListener('mousemove', doTrimDrag);
        trimCanvas.addEventListener('mouseup', endTrimDrag);
        trimCanvas.addEventListener('touchstart', startTrimDrag, { passive: false });
        trimCanvas.addEventListener('touchmove', doTrimDrag, { passive: false });
        trimCanvas.addEventListener('touchend', endTrimDrag);
    }

    function drawTrimCanvas() {
        if (!trimImg.src) return;
        
        trimCtx.clearRect(0, 0, trimCanvas.width, trimCanvas.height);
        
        if (trimmedResult) {
            // ìë¥´ê¸° ì‹¤í–‰ í›„ - ê²°ê³¼ ì´ë¯¸ì§€ í‘œì‹œ (ë¹„ìœ¨ ìœ ì§€)
            // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ìë¥¸ ì´ë¯¸ì§€ì— ë§ì¶¤
            trimCanvas.width = trimmedResult.width;
            trimCanvas.height = trimmedResult.height;
            
            // ìë¥¸ ì´ë¯¸ì§€ë¥¼ ê·¸ëŒ€ë¡œ í‘œì‹œ (ëŠ˜ë¦¬ì§€ ì•ŠìŒ)
            trimCtx.drawImage(trimmedResult, 0, 0);
        } else {
            // ìë¥´ê¸° ì „ - ì›ë³¸ ì´ë¯¸ì§€ + ì„ íƒ ì˜ì—­
            trimCtx.drawImage(trimImg, 0, 0, trimCanvas.width, trimCanvas.height);
            
            // ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´ (ì„ íƒ ì˜ì—­ ì™¸ë¶€)
            trimCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            trimCtx.fillRect(0, 0, trimCanvas.width, trimCanvas.height);
            
            // ì„ íƒ ì˜ì—­ í´ë¦¬ì–´ (ë°ê²Œ)
            trimCtx.clearRect(trimArea.x, trimArea.y, trimArea.width, trimArea.height);
            trimCtx.drawImage(
                trimImg,
                (trimArea.x / trimCanvas.width) * trimImg.width,
                (trimArea.y / trimCanvas.height) * trimImg.height,
                (trimArea.width / trimCanvas.width) * trimImg.width,
                (trimArea.height / trimCanvas.height) * trimImg.height,
                trimArea.x,
                trimArea.y,
                trimArea.width,
                trimArea.height
            );
            
            // ì„ íƒ ì˜ì—­ í…Œë‘ë¦¬
            trimCtx.strokeStyle = '#11593F';
            trimCtx.lineWidth = 3;
            trimCtx.strokeRect(trimArea.x, trimArea.y, trimArea.width, trimArea.height);
            
            // í•¸ë“¤ ê·¸ë¦¬ê¸°
            const handleSize = 12;
            trimCtx.fillStyle = '#11593F';
            
            // ëª¨ì„œë¦¬ í•¸ë“¤
            trimCtx.fillRect(trimArea.x - handleSize / 2, trimArea.y - handleSize / 2, handleSize, handleSize);
            trimCtx.fillRect(trimArea.x + trimArea.width - handleSize / 2, trimArea.y - handleSize / 2, handleSize, handleSize);
            trimCtx.fillRect(trimArea.x - handleSize / 2, trimArea.y + trimArea.height - handleSize / 2, handleSize, handleSize);
            trimCtx.fillRect(trimArea.x + trimArea.width - handleSize / 2, trimArea.y + trimArea.height - handleSize / 2, handleSize, handleSize);
            
            // ì¤‘ê°„ í•¸ë“¤
            trimCtx.fillRect(trimArea.x + trimArea.width / 2 - handleSize / 2, trimArea.y - handleSize / 2, handleSize, handleSize);
            trimCtx.fillRect(trimArea.x + trimArea.width / 2 - handleSize / 2, trimArea.y + trimArea.height - handleSize / 2, handleSize, handleSize);
            trimCtx.fillRect(trimArea.x - handleSize / 2, trimArea.y + trimArea.height / 2 - handleSize / 2, handleSize, handleSize);
            trimCtx.fillRect(trimArea.x + trimArea.width - handleSize / 2, trimArea.y + trimArea.height / 2 - handleSize / 2, handleSize, handleSize);
        }
    }

    function getCanvasCoords(e) {
        const rect = trimCanvas.getBoundingClientRect();
        const scaleX = trimCanvas.width / rect.width;
        const scaleY = trimCanvas.height / rect.height;
        
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    function getTrimHandle(x, y) {
        const touchSize = 50; // í„°ì¹˜ ì¸ì‹ ì˜ì—­ (ë„‰ë„‰í•˜ê²Œ)
        
        // ëª¨ì„œë¦¬ í•¸ë“¤ (í„°ì¹˜ ì˜ì—­ í™•ëŒ€)
        if (Math.abs(x - trimArea.x) < touchSize && Math.abs(y - trimArea.y) < touchSize) return 'nw';
        if (Math.abs(x - (trimArea.x + trimArea.width)) < touchSize && Math.abs(y - trimArea.y) < touchSize) return 'ne';
        if (Math.abs(x - trimArea.x) < touchSize && Math.abs(y - (trimArea.y + trimArea.height)) < touchSize) return 'sw';
        if (Math.abs(x - (trimArea.x + trimArea.width)) < touchSize && Math.abs(y - (trimArea.y + trimArea.height)) < touchSize) return 'se';
        
        // ì¤‘ê°„ í•¸ë“¤ (í„°ì¹˜ ì˜ì—­ í™•ëŒ€)
        if (Math.abs(x - (trimArea.x + trimArea.width / 2)) < touchSize && Math.abs(y - trimArea.y) < touchSize) return 'n';
        if (Math.abs(x - (trimArea.x + trimArea.width / 2)) < touchSize && Math.abs(y - (trimArea.y + trimArea.height)) < touchSize) return 's';
        if (Math.abs(x - trimArea.x) < touchSize && Math.abs(y - (trimArea.y + trimArea.height / 2)) < touchSize) return 'w';
        if (Math.abs(x - (trimArea.x + trimArea.width)) < touchSize && Math.abs(y - (trimArea.y + trimArea.height / 2)) < touchSize) return 'e';
        
        // ì˜ì—­ ë‚´ë¶€
        if (x > trimArea.x && x < trimArea.x + trimArea.width && y > trimArea.y && y < trimArea.y + trimArea.height) {
            return 'move';
        }
        
        return null;
    }

    function startTrimDrag(e) {
        if (trimmedResult) return; // ìë¥´ê¸° ì‹¤í–‰ í›„ì—ëŠ” ì¡°ì‘ ë¶ˆê°€
        
        e.preventDefault();
        const coords = getCanvasCoords(e);
        trimDragHandle = getTrimHandle(coords.x, coords.y);
        
        if (trimDragHandle) {
            trimDragging = true;
            trimDragStartX = coords.x;
            trimDragStartY = coords.y;
        }
    }

    function doTrimDrag(e) {
        if (!trimDragging || trimmedResult) return;
        
        e.preventDefault();
        const coords = getCanvasCoords(e);
        const dx = coords.x - trimDragStartX;
        const dy = coords.y - trimDragStartY;
        
        const minSize = 50;
        
        if (trimDragHandle === 'move') {
            trimArea.x = Math.max(0, Math.min(trimCanvas.width - trimArea.width, trimArea.x + dx));
            trimArea.y = Math.max(0, Math.min(trimCanvas.height - trimArea.height, trimArea.y + dy));
        } else if (trimDragHandle === 'nw') {
            const newX = Math.max(0, trimArea.x + dx);
            const newY = Math.max(0, trimArea.y + dy);
            const newWidth = trimArea.width + (trimArea.x - newX);
            const newHeight = trimArea.height + (trimArea.y - newY);
            if (newWidth >= minSize && newHeight >= minSize) {
                trimArea.x = newX;
                trimArea.y = newY;
                trimArea.width = newWidth;
                trimArea.height = newHeight;
            }
        } else if (trimDragHandle === 'ne') {
            const newY = Math.max(0, trimArea.y + dy);
            const newWidth = Math.max(minSize, trimArea.width + dx);
            const newHeight = trimArea.height + (trimArea.y - newY);
            if (newHeight >= minSize && trimArea.x + newWidth <= trimCanvas.width) {
                trimArea.y = newY;
                trimArea.width = newWidth;
                trimArea.height = newHeight;
            }
        } else if (trimDragHandle === 'sw') {
            const newX = Math.max(0, trimArea.x + dx);
            const newWidth = trimArea.width + (trimArea.x - newX);
            const newHeight = Math.max(minSize, trimArea.height + dy);
            if (newWidth >= minSize && trimArea.y + newHeight <= trimCanvas.height) {
                trimArea.x = newX;
                trimArea.width = newWidth;
                trimArea.height = newHeight;
            }
        } else if (trimDragHandle === 'se') {
            const newWidth = Math.max(minSize, trimArea.width + dx);
            const newHeight = Math.max(minSize, trimArea.height + dy);
            if (trimArea.x + newWidth <= trimCanvas.width && trimArea.y + newHeight <= trimCanvas.height) {
                trimArea.width = newWidth;
                trimArea.height = newHeight;
            }
        } else if (trimDragHandle === 'n') {
            const newY = Math.max(0, trimArea.y + dy);
            const newHeight = trimArea.height + (trimArea.y - newY);
            if (newHeight >= minSize) {
                trimArea.y = newY;
                trimArea.height = newHeight;
            }
        } else if (trimDragHandle === 's') {
            const newHeight = Math.max(minSize, trimArea.height + dy);
            if (trimArea.y + newHeight <= trimCanvas.height) {
                trimArea.height = newHeight;
            }
        } else if (trimDragHandle === 'w') {
            const newX = Math.max(0, trimArea.x + dx);
            const newWidth = trimArea.width + (trimArea.x - newX);
            if (newWidth >= minSize) {
                trimArea.x = newX;
                trimArea.width = newWidth;
            }
        } else if (trimDragHandle === 'e') {
            const newWidth = Math.max(minSize, trimArea.width + dx);
            if (trimArea.x + newWidth <= trimCanvas.width) {
                trimArea.width = newWidth;
            }
        }
        
        trimDragStartX = coords.x;
        trimDragStartY = coords.y;
        drawTrimCanvas();
    }

    function endTrimDrag(e) {
        trimDragging = false;
        trimDragHandle = null;
    }

    function resetTrimArea() {
        if (!trimImg.src) return;
        
        trimArea = {
            x: 0,
            y: 0,
            width: trimCanvas.width,
            height: trimCanvas.height
        };
        trimmedResult = null;
        drawTrimCanvas();
    }

    function setSquareTrim() {
        if (!trimImg.src) return;
        
        const size = Math.min(trimCanvas.width, trimCanvas.height);
        trimArea = {
            x: (trimCanvas.width - size) / 2,
            y: (trimCanvas.height - size) / 2,
            width: size,
            height: size
        };
        trimmedResult = null;
        drawTrimCanvas();
    }

    function resetTrimAll() {
        if (!trimImg.src) {
            alert('ì—…ë¡œë“œëœ ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        
        if (confirm('ìë¥´ê¸° ì‘ì—…ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
            // ì „ì²´ ì„ íƒìœ¼ë¡œ ë¦¬ì…‹
            trimArea = {
                x: 0,
                y: 0,
                width: trimCanvas.width,
                height: trimCanvas.height
            };
            trimmedResult = null;
            drawTrimCanvas();
        }
    }

    function executeTrim() {
        if (!trimImg.src) {
            alert('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”!');
            return;
        }
        
        // ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ìë¥´ê¸° ì˜ì—­ ê³„ì‚°
        const scaleX = trimImg.width / trimCanvas.width;
        const scaleY = trimImg.height / trimCanvas.height;
        
        const cropX = trimArea.x * scaleX;
        const cropY = trimArea.y * scaleY;
        const cropWidth = trimArea.width * scaleX;
        const cropHeight = trimArea.height * scaleY;
        
        // ê²°ê³¼ ìº”ë²„ìŠ¤ ìƒì„±
        const resultCanvas = document.createElement('canvas');
        resultCanvas.width = cropWidth;
        resultCanvas.height = cropHeight;
        const resultCtx = resultCanvas.getContext('2d');
        
        resultCtx.drawImage(
            trimImg,
            cropX, cropY, cropWidth, cropHeight,
            0, 0, cropWidth, cropHeight
        );
        
        // ê²°ê³¼ ì´ë¯¸ì§€ë¡œ ë³€í™˜
        trimmedResult = new Image();
        trimmedResult.src = resultCanvas.toDataURL();
        trimmedResult.onload = function() {
            drawTrimCanvas();
        };
    }

    function downloadTrimmedImage() {
        if (!trimmedResult) {
            alert('ë¨¼ì € "ìë¥´ê¸° ì‹¤í–‰" ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”!');
            return;
        }
        
        const link = document.createElement('a');
        link.download = `í˜¸ì†Œì¸_ìë¥´ê¸°_${getFormattedDate()}.png`;
        link.href = trimmedResult.src;
        link.click();
    }

    function shareTrimmedImage() {
        if (!trimmedResult) {
            alert('ë¨¼ì € "ìë¥´ê¸° ì‹¤í–‰" ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”!');
            return;
        }
        
        // Base64ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
        fetch(trimmedResult.src)
            .then(res => res.blob())
            .then(blob => {
                const file = new File([blob], `í˜¸ì†Œì¸_ìë¥´ê¸°_${getFormattedDate()}.png`, { type: 'image/png' });
                
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    navigator.share({
                        files: [file],
                        title: 'í˜¸ì†Œì¸ ì—ë””í„° - ìë¥´ê¸° ê²°ê³¼'
                    }).catch(err => {
                        console.log('ê³µìœ  ì·¨ì†Œ ë˜ëŠ” ì˜¤ë¥˜:', err);
                    });
                } else {
                    alert('ì´ ë¸Œë¼ìš°ì €ëŠ” ê³µìœ  ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ìš´ë¡œë“œë¥¼ ì´ìš©í•´ì£¼ì„¸ìš”.');
                }
            });
    }

    </script>

<!-- í•˜ë‹¨ ê´‘ê³  ì˜ì—­ -->
<!-- Google AdSense ë””ìŠ¤í”Œë ˆì´ ê´‘ê³  - ë³¸ì¸ì˜ ê´‘ê³  ì½”ë“œë¡œ êµì²´í•˜ì„¸ìš” -->
<!--
<div style="text-align: center; margin: 20px auto; max-width: 600px;">
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-XXXXXXXXXXXXXXXX"
         data-ad-slot="XXXXXXXXXX"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
-->

<!-- í‘¸í„° -->
<footer style="text-align: center; padding: 30px 20px; background: #f8f9fa; margin-top: 40px;">
    <div style="max-width: 600px; margin: 0 auto;">
        <p style="margin: 0 0 10px 0; font-size: 14px; color: #666;">
            Â© 2026 ì¸í”Œë£¨ì–¸ì„œ í˜¸ì†Œì¸ ì—ë””í„° by ê¹€ìŒ”ë­. All rights reserved.
        </p>
        <p style="margin: 0; font-size: 12px; color: #999;">
            <a href="/privacy.html" style="color: #999; text-decoration: none; margin: 0 10px;">ê°œì¸ì •ë³´ì²˜ë¦¬ë°©ì¹¨</a>
            <a href="/terms.html" style="color: #999; text-decoration: none; margin: 0 10px;">ì´ìš©ì•½ê´€</a>
            <a href="/contact.html" style="color: #999; text-decoration: none; margin: 0 10px;">ë¬¸ì˜í•˜ê¸°</a>
        </p>
    </div>
</footer>


    <script>
        // Lucide ì•„ì´ì½˜ ì´ˆê¸°í™”
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    </script>

</body>
</html>
